<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>字典树</title>
      <link href="/2019/01/02/algorithm-trieTree/"/>
      <url>/2019/01/02/algorithm-trieTree/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2018/10/02/algorithm-redBlackTree/"/>
      <url>/2018/10/02/algorithm-redBlackTree/</url>
      
        <content type="html"><![CDATA[<img src="/2018/10/02/algorithm-redBlackTree/1.1.jpg"><a id="more"></a><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p><p>红黑树的特性:<br>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p><h1 id="2-红黑树的应用"><a href="#2-红黑树的应用" class="headerlink" title="2.红黑树的应用"></a>2.红黑树的应用</h1><p>定理：一棵含有n个节点的红黑树的高度至多为2log(n+1).</p><p>证明：<br>    “一棵含有n个节点的红黑树的高度至多为2log(n+1)” 的逆否命题是 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。<br>    我们只需要证明逆否命题，即可证明原命题为真；即只需证明 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。</p><pre><code>从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x&apos;s black height)，记为bh(x)。关于bh(x)有两点需要说明：</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉排序树</title>
      <link href="/2018/10/01/algorithm-binarySortTree/"/>
      <url>/2018/10/01/algorithm-binarySortTree/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2018/09/27/algorithm-binaryTree/"/>
      <url>/2018/09/27/algorithm-binaryTree/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看，一棵二叉树！</p><img src="/2018/09/27/algorithm-binaryTree/1.1.jpg"><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>二叉树是每个节点最多有两个子树的树结构。</p><h2 id="形态"><a href="#形态" class="headerlink" title="形态"></a>形态</h2><p>如图2-1所示，二叉树有五种形态：</p><ol><li>节点数为0，空集</li><li>仅有一个根节点</li><li>仅有左树</li><li>仅有右树</li><li>左右树均有</li></ol><img src="/2018/09/27/algorithm-binaryTree/2.1.jpg" title="图2-1 二叉树的五种形态"><h2 id="满二叉树与完全二叉树"><a href="#满二叉树与完全二叉树" class="headerlink" title="满二叉树与完全二叉树"></a>满二叉树与完全二叉树</h2><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>如果二叉树中所有分支节点的度数都为2，并且叶子节点都在通一层次上，则二叉树为满二叉树。如图2-2所示：</p><img src="/2018/09/27/algorithm-binaryTree/2.2.jpg" title="图2-2 满二叉树"><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>对一棵具有n个节点的二叉树按层序排号，如果编号为i的节点与同样深度的满二叉树编号为i节点在二叉树中位置完全相同，就是完全二叉树。<br>满二叉树必须是完全二叉树，反之则不一定成立。如图2-3所示：</p><p><span id="tree_example"> </span><br><img src="/2018/09/27/algorithm-binaryTree/2.3.jpg" title="图2-3 完全二叉树"></p><p>完全二叉树有以下特点：</p><ol><li>叶子节点只能出现在最下一层</li><li>最下层叶子节点一定集中在左部连续位置。</li><li>倒数第二层，如有叶子节点，一定出现在右部连续位置。</li><li>同样节点树的二叉树，完全二叉树的深度最小。</li></ol><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ol><li>在二叉树的第i层上最多有 $ 2^{(i-1)} $ 个节点（i &gt;= 1）。</li><li>高度为k的二叉树，最多有 $ 2^k-1 $ 个节点 (k &gt;= 0)。</li><li>对任何一棵二叉树，如果其叶节点有n个，度为2的非叶子节点有m个，则n = m + 1。（该性质的证明见<a href="#appendix">附录</a>）</li><li>具有n个节点的完全二叉树的高度为 $ [log_2n] + 1 $</li></ol><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>由于二叉树每个节点最多只有两个子节点，因此通常每个节点中有两个指向子节点的指针，如图3-1所示：<br><img src="/2018/09/27/algorithm-binaryTree/3.1.jpg" title="图3-1 二叉树的存储结构"><br>有时为了回溯父节点方便，还会在节点中增加一个指向父节点的指针。</p><p>java代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Integer val;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    Node parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer val, Node left, Node right, Node parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getVal</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(Integer val)</span> </span>&#123; his.val = val; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeft</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> left; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(Node left)</span> </span>&#123; <span class="keyword">this</span>.left = left; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRight</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> right; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(Node right)</span> </span>&#123; <span class="keyword">this</span>.right = right; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getParent</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> parent; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(Node parent)</span> </span>&#123; <span class="keyword">this</span>.parent = parent; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>对于一棵二叉树而言，主要有遍历、查找、插入、删除、查询树的高度、树的节点数量以及某个节点的层次等操作。</p><p>我们知道二叉树中的每个节点又包含了两棵子二叉树，这本身就是一种递归思想的体现，因此对二叉树的大部分操作使用递归的思想都可以很方便的实现。</p><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p>广度优先遍历实际就是按层次遍历，按节点层次从低到高的顺序遍历所有节点。</p><p>比如<a href="#tree_example">图2-3</a>中的二叉树的广度优先遍历为：<br>1 2 3 4 5 6 7 8 9 10</p><p>广度优先遍历似乎不太好用递归实现。</p><p>广度优先遍历需要使用队列：<br>（1）首先向队列中插入二叉树的根节点<br>（2）检查队列中是否有元素，如果队列中没有元素，遍历结束，如果有元素，进行下一步<br>（3）将队列中的第一个节点弹出，遍历该节点<br>（4）检查弹出的节点是否有左右子节点，若有，将其插入队列中<br>（5）重复步骤（2）</p><p>该遍历方法运用了队列“先进先出”的特性，先插入的节点也先弹出被遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@brief</span> 广度优先遍历 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breadthFisrtTraverse</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    queue.add(node);</span><br><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node n = queue.removeFirst();</span><br><span class="line">        System.out.print(n.val + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n.left != <span class="keyword">null</span>)</span><br><span class="line">            queue.addLast(n.left);</span><br><span class="line">        <span class="keyword">if</span> (n.right != <span class="keyword">null</span>)</span><br><span class="line">            queue.addLast(n.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p>深度优先遍历是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</p><p>深度优先遍历根据遍历时根节点的位置又分为前序、中序和后续遍历。</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>前序遍历是指按照“根-&gt;左-&gt;右”的顺序，深度遍历二叉树。</p><p>比如<a href="#tree_example">图2-3</a>中的二叉树的前序遍历为：<br>1 2 4 8 9 5 10 3 6 7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@brief</span> 前序遍历 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)   <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印本节点内容</span></span><br><span class="line">    System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">    <span class="comment">// 打印左子树</span></span><br><span class="line">    preOrder(node.left);</span><br><span class="line">    <span class="comment">// 打印右子树</span></span><br><span class="line">    preOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历是指按照“左-&gt;根-&gt;右”的顺序，深度遍历二叉树。</p><p>比如<a href="#tree_example">图2-3</a>中的二叉树的中序遍历为：<br>8 4 9 2 10 5 1 6 3 7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@brief</span> 中序遍历 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)   <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印左子树</span></span><br><span class="line">    midOrder(node.left);</span><br><span class="line">    <span class="comment">// 打印本节点内容</span></span><br><span class="line">    System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">    <span class="comment">// 打印右子树</span></span><br><span class="line">    midOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>前序遍历是指按照“左-&gt;右-&gt;根”的顺序，深度遍历二叉树。</p><p>比如<a href="#tree_example">图2-3</a>中的二叉树的后序遍历为：<br>8 9 4 10 5 2 6 7 3 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@brief</span> 后序遍历 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)   <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印左子树</span></span><br><span class="line">    postOrder(node.left);</span><br><span class="line">    <span class="comment">// 打印右子树</span></span><br><span class="line">    postOrder(node.right);</span><br><span class="line">    <span class="comment">// 打印本节点内容</span></span><br><span class="line">    System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找、插入和删除"><a href="#查找、插入和删除" class="headerlink" title="查找、插入和删除"></a>查找、插入和删除</h2><p>节点的查找、插入和删除其实都和树的节点顺序有关，比如常用的二叉排序树(BST)中，左节点&lt;根&lt;右节点。因此相关内容将在二叉排序树中再细讲。</p><h2 id="查询树的高度"><a href="#查询树的高度" class="headerlink" title="查询树的高度"></a>查询树的高度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@brief</span> 查询以该节点为根的树的高度 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">height</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(height(node.left), height(node.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询树的节点数量"><a href="#查询树的节点数量" class="headerlink" title="查询树的节点数量"></a>查询树的节点数量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@brief</span> 查询以该节点为根的树的节点数量 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">nodesNum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + nodesNum(node.right) + nodesNum(node.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询节点的层次"><a href="#查询节点的层次" class="headerlink" title="查询节点的层次"></a>查询节点的层次</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@brief</span> 查询节点的层级 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">level</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == root) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> level(node.parent) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><span id="appendix">附录</span></h1><h2 id="性质3的证明"><a href="#性质3的证明" class="headerlink" title="性质3的证明"></a>性质3的证明</h2><p>试证明: 对任何一棵二叉树，如果其叶节点有n个，度为2的非叶子节点有m个，则n = m + 1。<br>证： 设一棵二叉树度为0的节点个数为 $ n_0 $, 度为1的节点个数为 $ n_1 $, 度为2的节点个数为 $ n_2 $, 二叉树的节点总数为 k 。<br>则：<br>$ k=0 \times n_0+1 \times n_1+2 \times n_2 + 1 $              —— (式 1)<br>$ k=n_0+n_1+n_2 $                                   —— (式 2)<br>两式相减可得：<br>$ n_0=n_2+1 $  —— (式 3)</p><p>由题可知：叶子节点即度为0的节点，即：$ n_0 = n $;<br>度为2的非叶子节点即度为2的节点，即：$ n_2 = m $;</p><p>代入式3可得：<br>$ n=m+1 $</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2018/09/10/algorithm-Tree/"/>
      <url>/2018/09/10/algorithm-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天说说树。下面这就是一棵树：<br><img src="/2018/09/10/algorithm-Tree/1.1.jpg"></p><p>当然我们今天要说的是一种数据结构 - 树。<br><a id="more"></a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>树是8种基础数据结构（数组Array、栈Stack、队列Queue、链表LinkedList、树Tree、图Graph、堆Heap、散列表HashTable）之一。</p><p>一棵树通常可以表示为图2-1的形式，由于其形似一棵倒置的树，它也因此而得名。<br><img src="/2018/09/10/algorithm-Tree/2.1.jpg" title="图2-1 树"></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>树(Tree)是包含n(n &gt;= 0)个节点的有穷集合。<br>当 n=0 时，称为 <strong>空树</strong>。<br>对于任一棵 <strong>非空树</strong>（n &gt; 0），其满足以下特性：</p><ul><li>树中的每个元素称之为 <strong>节点</strong>（node）</li><li>有一个特殊的节点称之为 <strong>根节点</strong>（root），根节点没有父节点</li><li>除根节点之外的其余数据元素被分为m（m&gt;=0）个互不相交的集合T1，T2，……，Tm-1，其中每一个集合Ti(1&lt;=i&lt;=m)本身也是一棵树，被称作原树的 <strong>子树</strong>（subtree）</li></ul><p>根据上述定义，可以判断图2-2中的均不是树<br><img src="/2018/09/10/algorithm-Tree/2.2.jpg" title="图2-2 非树"></p><p>我们也可以推导出树的一些性质:</p><ul><li>子树是不相交的</li><li>除了根节点没有父节点，其余每个节点有且只有一个父节点</li><li>一棵有n个节点的树，有n-1条边</li></ul><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>在笔者看来，树这种数据结构之所以存在有两方面原因：</p><ol><li>自然界中本来就存在着许多以树状结构存在的事物（比如公司或部门的组织架构，家族图谱等），而程序是对自然界事物的抽象，那么树这种数据结构的出现就非常自然了；</li><li>在一些大数据量的场景下，树这种数据结构的搜索、插入、删除的综合性能相较与数组、链表有优势。</li></ol><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul><li>节点的度（Degree）：一个节点含有的子树的个数称为该节点的度；</li><li>叶子节点（Leaf）：度为0的节点称为叶节点；</li><li>非终端节点或分支节点：度不为0的节点；</li><li>父节点（Parent）：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li><li>子节点（Child）：一个节点含有的子树的根节点称为该节点的子节点；</li><li>兄弟节点（Sibling）：具有相同父节点的节点互称为兄弟节点；</li><li>树的度：一棵树中，最大的节点的度称为树的度；</li><li>节点的层次（Level）：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li><li>树的高度或深度（Depth）：树中节点的最大层次；</li><li>祖先（Ancestor）：从根到该节点所经分支上的所有节点都称为该节点的祖先；</li><li>子孙（Descendant）：以某节点为根的子树中任一节点都称为该节点的子孙。</li></ul><h1 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h1><p>由于树的子节点的数量是不确定的，因此通常在节点内部使用链表在存储该节点的子节点，这种表示方法也被称为孩子兄弟表示法，即：</p><ul><li>每个节点都有一个指向其第一个孩子的指针；</li><li>每个节点都有一个指向其第一个右兄弟的指针。</li></ul><p>图2-1中的树的存储结构可以表示为图3-1所示：<br><img src="/2018/09/10/algorithm-Tree/3.1.jpg" title="图3-1 孩子兄弟表示法"></p><h1 id="分类及应用"><a href="#分类及应用" class="headerlink" title="分类及应用"></a>分类及应用</h1><h2 id="根据是否有序分类"><a href="#根据是否有序分类" class="headerlink" title="根据是否有序分类"></a>根据是否有序分类</h2><ul><li>无序树<br>树的任意节点的子节点没有顺序关系。</li><li>有序树<br>树的任意节点的子节点有顺序关系。</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是应用非常广泛的一种树。<br>二叉树是指：树的任意节点至多包含两棵子树。</p><ul><li>满二叉树<br>叶子节点都在同一层并且除叶子节点外的所有节点都有两个子节点。</li><li>完全二叉树<br>对于一颗二叉树，假设其深度为d（d&gt;1）。除第d层外的所有节点构成满二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树。</li><li>平衡二叉树<br>它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树。</li></ul><h2 id="常用的树"><a href="#常用的树" class="headerlink" title="常用的树"></a>常用的树</h2><ul><li>二叉查找树（又称二叉搜索树、二叉排序树、BST）<br>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；<br>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；<br>任意节点的左、右子树也分别为二叉查找树；<br>没有键值相等的节点。</li><li>红黑树<br>红黑树是一颗特殊的二叉查找树，它有自平衡的特性，主要用于解决二叉查找树在某些情况下退化为链表而导致性能下降的问题。</li><li>字典树<br>又称单词查找树，Trie树，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。</li><li>后缀树<br>后缀树（Suffix tree）就是包含一则字符串所有后缀的压缩Trie树。</li><li>霍夫曼树<br>带权路径最短的二叉树称为哈夫曼树或最优二叉树。</li><li>2-3树、B树、B+树、B*树<br>均为平衡查找树。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
