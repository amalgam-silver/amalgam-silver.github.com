<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字典树]]></title>
    <url>%2F2019%2F01%2F02%2Falgorithm-trieTree%2F</url>
    <content type="text"></content>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2018%2F10%2F02%2Falgorithm-redBlackTree%2F</url>
    <content type="text"><![CDATA[1.简介R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。 红黑树的特性:（1）每个节点或者是黑色，或者是红色。（2）根节点是黑色。（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]（4）如果一个节点是红色的，则它的子节点必须是黑色的。（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 2.红黑树的应用定理：一棵含有n个节点的红黑树的高度至多为2log(n+1). 证明： “一棵含有n个节点的红黑树的高度至多为2log(n+1)” 的逆否命题是 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。 我们只需要证明逆否命题，即可证明原命题为真；即只需证明 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。 从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x&apos;s black height)，记为bh(x)。关于bh(x)有两点需要说明：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉排序树]]></title>
    <url>%2F2018%2F10%2F01%2Falgorithm-binarySortTree%2F</url>
    <content type="text"><![CDATA[介绍原理数据结构插入删除遍历代码实现]]></content>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2018%2F09%2F27%2Falgorithm-binaryTree%2F</url>
    <content type="text"><![CDATA[前言看，一棵二叉树！ 介绍定义二叉树是每个节点最多有两个子树的树结构。 形态如图2-1所示，二叉树有五种形态： 节点数为0，空集 仅有一个根节点 仅有左树 仅有右树 左右树均有 满二叉树与完全二叉树满二叉树如果二叉树中所有分支节点的度数都为2，并且叶子节点都在通一层次上，则二叉树为满二叉树。如图2-2所示： 完全二叉树对一棵具有n个节点的二叉树按层序排号，如果编号为i的节点与同样深度的满二叉树编号为i节点在二叉树中位置完全相同，就是完全二叉树。满二叉树必须是完全二叉树，反之则不一定成立。如图2-3所示： 完全二叉树有以下特点： 叶子节点只能出现在最下一层 最下层叶子节点一定集中在左部连续位置。 倒数第二层，如有叶子节点，一定出现在右部连续位置。 同样节点树的二叉树，完全二叉树的深度最小。 二叉树的性质 在二叉树的第i层上最多有 $ 2^{(i-1)} $ 个节点（i &gt;= 1）。 高度为k的二叉树，最多有 $ 2^k-1 $ 个节点 (k &gt;= 0)。 对任何一棵二叉树，如果其叶节点有n个，度为2的非叶子节点有m个，则n = m + 1。（该性质的证明见附录） 具有n个节点的完全二叉树的高度为 $ [log_2n] + 1 $ 存储结构由于二叉树每个节点最多只有两个子节点，因此通常每个节点中有两个指向子节点的指针，如图3-1所示：有时为了回溯父节点方便，还会在节点中增加一个指向父节点的指针。 java代码：12345678910111213141516171819202122232425262728293031class Node &#123; Integer val; Node left; Node right; Node parent; public Node() &#123; &#125; public Node(Integer val, Node left, Node right, Node parent) &#123; this.val = val; this.left = left; this.right = right; this.parent = parent; &#125; public Integer getVal() &#123; return val; &#125; public void setVal(Integer val) &#123; his.val = val; &#125; public Node getLeft() &#123; return left; &#125; public void setLeft(Node left) &#123; this.left = left; &#125; public Node getRight() &#123; return right; &#125; public void setRight(Node right) &#123; this.right = right; &#125; public Node getParent() &#123; return parent; &#125; public void setParent(Node parent) &#123; this.parent = parent; &#125;&#125; 操作对于一棵二叉树而言，主要有遍历、查找、插入、删除、查询树的高度、树的节点数量以及某个节点的层次等操作。 我们知道二叉树中的每个节点又包含了两棵子二叉树，这本身就是一种递归思想的体现，因此对二叉树的大部分操作使用递归的思想都可以很方便的实现。 广度优先遍历广度优先遍历实际就是按层次遍历，按节点层次从低到高的顺序遍历所有节点。 比如图2-3中的二叉树的广度优先遍历为：1 2 3 4 5 6 7 8 9 10 广度优先遍历似乎不太好用递归实现。 广度优先遍历需要使用队列：（1）首先向队列中插入二叉树的根节点（2）检查队列中是否有元素，如果队列中没有元素，遍历结束，如果有元素，进行下一步（3）将队列中的第一个节点弹出，遍历该节点（4）检查弹出的节点是否有左右子节点，若有，将其插入队列中（5）重复步骤（2） 该遍历方法运用了队列“先进先出”的特性，先插入的节点也先弹出被遍历。 123456789101112131415/** @brief 广度优先遍历 */public void breadthFisrtTraverse(Node node) &#123; LinkedList&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); queue.add(node); while (queue.size() &gt; 0) &#123; Node n = queue.removeFirst(); System.out.print(n.val + " "); if (n.left != null) queue.addLast(n.left); if (n.right != null) queue.addLast(n.right); &#125;&#125; 深度优先遍历深度优先遍历是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。 深度优先遍历根据遍历时根节点的位置又分为前序、中序和后续遍历。 前序遍历前序遍历是指按照“根-&gt;左-&gt;右”的顺序，深度遍历二叉树。 比如图2-3中的二叉树的前序遍历为：1 2 4 8 9 5 10 3 6 7 1234567891011/** @brief 前序遍历 */public void preOrder(Node node) &#123; if (node == null) return; // 打印本节点内容 System.out.print(node.val + " "); // 打印左子树 preOrder(node.left); // 打印右子树 preOrder(node.right);&#125; 中序遍历中序遍历是指按照“左-&gt;根-&gt;右”的顺序，深度遍历二叉树。 比如图2-3中的二叉树的中序遍历为：8 4 9 2 10 5 1 6 3 7 1234567891011/** @brief 中序遍历 */public void midOrder(Node node) &#123; if (node == null) return; // 打印左子树 midOrder(node.left); // 打印本节点内容 System.out.print(node.val + " "); // 打印右子树 midOrder(node.right);&#125; 后序遍历前序遍历是指按照“左-&gt;右-&gt;根”的顺序，深度遍历二叉树。 比如图2-3中的二叉树的后序遍历为：8 9 4 10 5 2 6 7 3 1 1234567891011/** @brief 后序遍历 */public void postOrder(Node node) &#123; if (node == null) return; // 打印左子树 postOrder(node.left); // 打印右子树 postOrder(node.right); // 打印本节点内容 System.out.print(node.val + " ");&#125; 查找插入删除查询树的高度123456/** @brief 查询以该节点为根的树的高度 */public Integer height(Node node) &#123; if (node == null) return 0; return 1 + Math.max(height(node.left), height(node.right));&#125; 查询树的节点数量123456/** @brief 查询以该节点为根的树的节点数量 */public Integer nodesNum(Node node) &#123; if (node == null) return 0; return 1 + nodesNum(node.right) + nodesNum(node.left);&#125; 查询节点的层次123456/** @brief 查询节点的层级 */public Integer level(Node node) &#123; if (node == root) return 1; return level(node.parent) + 1;&#125; 附录性质3的证明试证明: 对任何一棵二叉树，如果其叶节点有n个，度为2的非叶子节点有m个，则n = m + 1。证： 设一棵二叉树度为0的节点个数为 $ n_0 $, 度为1的节点个数为 $ n_1 $, 度为2的节点个数为 $ n_2 $, 二叉树的节点总数为 k 。则：$ k=0 \times n_0+1 \times n_1+2 \times n_2 + 1 $ —— (式 1)$ k=n_0+n_1+n_2 $ —— (式 2)两式相减可得：$ n_0=n_2+1 $ —— (式 3) 由题可知：叶子节点即度为0的节点，即：$ n_0 = n $;度为2的非叶子节点即度为2的节点，即：$ n_2 = m $; 代入式3可得：$ n=m+1 $ 完整代码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2018%2F09%2F10%2Falgorithm-Tree%2F</url>
    <content type="text"><![CDATA[前言今天说说树。下面这就是一棵树： 当然我们今天要说的是一种数据结构 - 树。 介绍树是8种基础数据结构（数组Array、栈Stack、队列Queue、链表LinkedList、树Tree、图Graph、堆Heap、散列表HashTable）之一。 一棵树通常可以表示为图2-1的形式，由于其形似一棵倒置的树，它也因此而得名。 定义树(Tree)是包含n(n &gt;= 0)个节点的有穷集合。当 n=0 时，称为 空树。对于任一棵 非空树（n &gt; 0），其满足以下特性： 树中的每个元素称之为 节点（node） 有一个特殊的节点称之为 根节点（root），根节点没有父节点 除根节点之外的其余数据元素被分为m（m&gt;=0）个互不相交的集合T1，T2，……，Tm-1，其中每一个集合Ti(1&lt;=i&lt;=m)本身也是一棵树，被称作原树的 子树（subtree） 根据上述定义，可以判断图2-2中的均不是树 我们也可以推导出树的一些性质: 子树是不相交的 除了根节点没有父节点，其余每个节点有且只有一个父节点 一棵有n个节点的树，有n-1条边 意义在笔者看来，树这种数据结构之所以存在有两方面原因： 自然界中本来就存在着许多以树状结构存在的事物（比如公司或部门的组织架构，家族图谱等），而程序是对自然界事物的抽象，那么树这种数据结构的出现就非常自然了； 在一些大数据量的场景下，树这种数据结构的搜索、插入、删除的综合性能相较与数组、链表有优势。 相关术语 节点的度（Degree）：一个节点含有的子树的个数称为该节点的度； 叶子节点（Leaf）：度为0的节点称为叶节点； 非终端节点或分支节点：度不为0的节点； 父节点（Parent）：若一个节点含有子节点，则这个节点称为其子节点的父节点； 子节点（Child）：一个节点含有的子树的根节点称为该节点的子节点； 兄弟节点（Sibling）：具有相同父节点的节点互称为兄弟节点； 树的度：一棵树中，最大的节点的度称为树的度； 节点的层次（Level）：从根开始定义起，根为第1层，根的子节点为第2层，以此类推； 树的高度或深度（Depth）：树中节点的最大层次； 祖先（Ancestor）：从根到该节点所经分支上的所有节点都称为该节点的祖先； 子孙（Descendant）：以某节点为根的子树中任一节点都称为该节点的子孙。 存储模型由于树的子节点的数量是不确定的，因此通常在节点内部使用链表在存储该节点的子节点，这种表示方法也被称为孩子兄弟表示法，即： 每个节点都有一个指向其第一个孩子的指针； 每个节点都有一个指向其第一个右兄弟的指针。 图2-1中的树的存储结构可以表示为图3-1所示： 分类及应用根据是否有序分类 无序树树的任意节点的子节点没有顺序关系。 有序树树的任意节点的子节点有顺序关系。 二叉树二叉树是应用非常广泛的一种树。二叉树是指：树的任意节点至多包含两棵子树。 满二叉树叶子节点都在同一层并且除叶子节点外的所有节点都有两个子节点。 完全二叉树对于一颗二叉树，假设其深度为d（d&gt;1）。除第d层外的所有节点构成满二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树。 平衡二叉树它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树。 常用的树 二叉查找树（又称二叉搜索树、二叉排序树、BST）若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；任意节点的左、右子树也分别为二叉查找树；没有键值相等的节点。 红黑树红黑树是一颗特殊的二叉查找树，它有自平衡的特性，主要用于解决二叉查找树在某些情况下退化为链表而导致性能下降的问题。 字典树又称单词查找树，Trie树，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。 后缀树后缀树（Suffix tree）就是包含一则字符串所有后缀的压缩Trie树。 霍夫曼树带权路径最短的二叉树称为哈夫曼树或最优二叉树。 2-3树、B树、B+树、B*树均为平衡查找树。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
