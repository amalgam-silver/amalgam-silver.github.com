<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM-垃圾回收（1）-- 基础知识</title>
      <link href="/2020/10/27/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%881%EF%BC%89/"/>
      <url>/2020/10/27/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>何为垃圾</li><li>如何发现垃圾？</li><li>如何回收垃圾？</li><li>堆内存逻辑分区</li><li>常见垃圾回收器</li></ul><a id="more"></a><h1 id="垃圾（Garbage）"><a href="#垃圾（Garbage）" class="headerlink" title="垃圾（Garbage）"></a>垃圾（Garbage）</h1><pre><code>何为垃圾！？</code></pre><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>没有任何引用指向的单个或多个对象。</p><p><img src="/2020/10/27/JVM-垃圾回收（1）/1.png" alt="Garbage"></p><h2 id="C-C-的处理"><a href="#C-C-的处理" class="headerlink" title="C/C++ 的处理"></a>C/C++ 的处理</h2><p>C：</p><ul><li>malloc 申请内存</li><li>free 释放内存</li></ul><p>C++：</p><ul><li>new 创建对象</li><li>delete 销毁对象</li></ul><h2 id="java-的处理"><a href="#java-的处理" class="headerlink" title="java 的处理"></a>java 的处理</h2><ul><li>new 创建对象</li><li>自动回收对象</li></ul><h2 id="C-C-vs-java"><a href="#C-C-vs-java" class="headerlink" title="C/C++ vs java"></a>C/C++ vs java</h2><p>C/C++：</p><ul><li>手动处理垃圾，容易出错：<ol><li>忘记回收 -&gt; 内存泄露</li><li>多次回收 -&gt; 非法访问</li></ol></li><li>开发效率低，执行效率高</li></ul><p>java：</p><ul><li>GC处理垃圾</li><li>开发效率高，执行效率低</li></ul><h1 id="垃圾定位方法"><a href="#垃圾定位方法" class="headerlink" title="垃圾定位方法"></a>垃圾定位方法</h1><h2 id="引用计数（Reference-Count）"><a href="#引用计数（Reference-Count）" class="headerlink" title="引用计数（Reference Count）"></a>引用计数（Reference Count）</h2><ul><li>每多一个引用指向某个对象，就将该对象的引用计数值+1，反之亦然。</li></ul><p><img src="/2020/10/27/JVM-垃圾回收（1）/2.png" alt="引用计数"></p><ul><li>无法解决循环引用（即几个对象相互引用，但实际并没有外部引用指向这其中的任何一个对象，因此这几个对象都是垃圾，但是他们的引用计数都不为0）的问题。</li></ul><p><img src="/2020/10/27/JVM-垃圾回收（1）/3.png" alt="循环引用"></p><h2 id="根可达算法（Root-Searching）"><a href="#根可达算法（Root-Searching）" class="headerlink" title="根可达算法（Root Searching）"></a>根可达算法（Root Searching）</h2><ul><li>从根对象（GC Roots）开始搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时，则此对象垃圾。</li><li><p>哪些对象是根对象：</p><ol><li>线程栈变量 JVM stacks</li><li>JNI变量 native method stacks</li><li>常量池 runtime constant pool</li><li>静态变量 static reference in method area，Clazz</li></ol></li></ul><p><img src="/2020/10/27/JVM-垃圾回收（1）/4.png" alt="根可达算法"></p><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记清除（Mark-Sweep）"><a href="#标记清除（Mark-Sweep）" class="headerlink" title="标记清除（Mark-Sweep）"></a>标记清除（Mark-Sweep）</h2><ul><li>如下图所示，将标记为垃圾的内存直接清理。</li></ul><p><img src="/2020/10/27/JVM-垃圾回收（1）/5.png" alt="标记清除"></p><ul><li><p>特点：</p><ul><li>垃圾的内存位置不连续，容易产生碎片；</li><li>整个过程需要两遍扫描，效率偏低；</li><li>存活对象较多的情况下，效率相对较高。</li></ul></li></ul><h2 id="拷贝（Copying）"><a href="#拷贝（Copying）" class="headerlink" title="拷贝（Copying）"></a>拷贝（Copying）</h2><ul><li>如下图所示，将内存分为两块区域，每次只用其中一块区域，垃圾回收时，将存活的对象拷贝到另一半区域。</li></ul><p><img src="/2020/10/27/JVM-垃圾回收（1）/6.png" alt="拷贝"></p><ul><li><p>特点：</p><ul><li>没有碎片；</li><li>浪费空间；</li><li>移动赋值对象，指针所指的对象地址需要调整；</li><li>只需要扫描一次，效率较高；</li><li>存活对象较少的情况下，效率相对较高。</li></ul></li></ul><h2 id="标记压缩（Mark-Compact）"><a href="#标记压缩（Mark-Compact）" class="headerlink" title="标记压缩（Mark-Compact）"></a>标记压缩（Mark-Compact）</h2><ul><li>如下图所示，垃圾回收时，将存活的对象搬运到连续的内存中。</li></ul><p><img src="/2020/10/27/JVM-垃圾回收（1）/7.png" alt="标记压缩"></p><ul><li><p>特点：</p><ul><li>没有碎片；</li><li>整个过程需要两遍扫描，并且由于需要搬运对象，指针所指的对象地址需要调整，效率偏低。</li></ul></li></ul><h1 id="内存逻辑分区"><a href="#内存逻辑分区" class="headerlink" title="内存逻辑分区"></a>内存逻辑分区</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>可以看到不同的垃圾回收算法也有其各自的适用场景，因此，HotSpot在实现垃圾回收时，将堆内存划分成了两个区域：新生代（Young）和老年代（Old）。</p><p>顾名思义，新生代里存放的都是最近产生的对象，而老年代里，存放的是经过多次垃圾回收后，仍然存活的对象。因此，两者相较而言，垃圾回收时，通常新生代里存活的对象较少，而老年代里存活的对象较多。</p><p>根据不同区域中对象的特点不同，采用不同的垃圾回收器。</p><p>后面随着软硬件的发展，出现了不分代的垃圾回收器（如：G1 逻辑上分代，物理上不分代；ZGC，Shenandoah 逻辑和物理上都不分代）</p><p>因此，分代模型仅针对除了 Epsilon、ZGC 和 Shenandoah 以外的垃圾回收器。</p><h2 id="分代模型"><a href="#分代模型" class="headerlink" title="分代模型"></a>分代模型</h2><ul><li>新生代（young）</li><li>老年代（old）</li><li>永久代（Perm Generation）/ 元数据区（Metaspace）</li></ul><p>备注：</p><ol><li><strong>堆（Heap）</strong> 分为 <strong>新生代</strong> 和 <strong>老年代</strong>。</li><li><strong>永久代</strong> 和 <strong>元数据区</strong> 都是 <strong>方法区（Method Area）</strong> 的具体实现，在jdk1.7及之前的版本中，叫 <strong>永久代</strong>，在jdk1.8及之后的版本中叫 <strong>元数据区</strong>。</li><li>Class对象在永久代/元数据区中。</li><li>永久代必须指定大小，运行过程中大小不会变，存满即报OOM，FGC不会清理Perm Generation；元数据区若不指定大小，则大小受限于物理内存，会触发FGC</li><li>字符串常量在jdk1.7及之前版本中，存放于 <strong>永久代</strong>，在jdk1.8及之后版本中，存放于 <strong>堆</strong>。</li><li>GC概念：<ul><li>MinorGC/YGC：对年轻代进行垃圾回收称为 <strong>MinorGC</strong> 或 <strong>YGC</strong>。年轻代空间耗尽时触发。</li><li>MajorGC/FullGC：对新生代和老年代都进行垃圾回收称为 <strong>MajorGC</strong> 或 <strong>FullGC</strong>。在老年代无法继续分配空间时触发。</li></ul></li></ol><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>新生代（<strong>Young</strong>）又划分为 <strong>Eden</strong> 区 和 2个 <strong>survivor</strong> 区（s0 和 s1）。</p><p>Eden（伊甸）区 存放新生成的对象；两个Survivor（幸存）区 交替存放每次YGC后，存活下来的对象。</p><p>GC过程：</p><ul><li>YGC后，大多数对象被回收，存活的对象进入 <strong>s0</strong> 区</li><li>再次YGC，<strong>eden</strong> 区和 <strong>s0</strong> 区活着的对象进入 <strong>s1</strong> 区</li><li>再次YGC，<strong>eden</strong> 区和 <strong>s1</strong> 区活着的对象进入 <strong>s0</strong> 区</li><li>…</li><li>对象年龄足够，进入老年代。（CMS - 幸存6次后进入老年代；其他 - 幸存15次后进入老年代）</li></ul><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代(<strong>Old</strong>)中存储的通常是顽固不易被回收的对象。老年代满了会触发FullGC。</p><h2 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h2><p><img src="/2020/10/27/JVM-垃圾回收（1）/8.png" alt="对象分配过程"></p><h2 id="动态年龄"><a href="#动态年龄" class="headerlink" title="动态年龄"></a>动态年龄</h2><h2 id="分配担保"><a href="#分配担保" class="headerlink" title="分配担保"></a>分配担保</h2><h1 id="常见垃圾回收器"><a href="#常见垃圾回收器" class="headerlink" title="常见垃圾回收器"></a>常见垃圾回收器</h1><p><img src="/2020/10/27/JVM-垃圾回收（1）/9.png" alt="常见垃圾回收器"></p><p>如上图所示，除了 <strong>Epsilon</strong> 是用于调试以外，垃圾回收器大致可分为两类：使用分代模型的和不使用分代模型的。</p><h2 id="几个基础概念"><a href="#几个基础概念" class="headerlink" title="几个基础概念"></a>几个基础概念</h2><p>STW：</p><ul><li>stop the world的缩写。</li><li>是指垃圾回收线程工作时，其他所有线程都暂停，等垃圾回收完毕，再恢复继续工作。</li><li>STW期间，业务线程也停了，因此业务会表现出没有响应的现象。</li><li>目前，所有的垃圾回收都有STW</li></ul><p>safe point：</p><h2 id="基于分代模型的垃圾回收器"><a href="#基于分代模型的垃圾回收器" class="headerlink" title="基于分代模型的垃圾回收器"></a>基于分代模型的垃圾回收器</h2><p>使用分代模型的垃圾回收器，通常成对出现，分别用于Young区和Old区：</p><h3 id="Serial-和-Serial-Old："><a href="#Serial-和-Serial-Old：" class="headerlink" title="Serial 和 Serial Old："></a><strong>Serial</strong> 和 <strong>Serial Old</strong>：</h3><ul><li>单线程回收</li><li>单CPU情况下，效率最高</li><li>适用于堆内存在 <strong>几十M左右</strong> 的情况</li><li><strong>Serial</strong>使用拷贝算法，<strong>Serial Old</strong>使用标记清除压缩算法</li><li><strong>Serial</strong>: a stop-the-world, copying collector which uses a single GC thread</li><li><strong>Serial Old</strong>: a stop-the-world, mark-sweep-compact collector that uses a single GC thread</li></ul><p><img src="/2020/10/27/JVM-垃圾回收（1）/10.png" alt="Serial"></p><h3 id="Parallel-Scavenge-和-Parallel-Old"><a href="#Parallel-Scavenge-和-Parallel-Old" class="headerlink" title="Parallel Scavenge 和 Parallel Old:"></a><strong>Parallel Scavenge</strong> 和 <strong>Parallel Old</strong>:</h3><ul><li>多线程回收</li><li>适用于堆内存在 <strong>上百M</strong> 到 <strong>几个G</strong> 之间的情况</li><li>是jdk1.8的默认垃圾回收器</li><li><strong>Parallel Scavenge</strong>使用拷贝算法，<strong>Parallel Old</strong>使用标记压缩算法</li><li>Parallel Scavenge: a stop-the-world, copying collector which uses multiple GC threads</li><li>Parallel Old：a stop-the world, compacting collector that uses multiple GC threads</li></ul><p><img src="/2020/10/27/JVM-垃圾回收（1）/11.png" alt="Parallel"></p><h3 id="ParNew-和-CMS"><a href="#ParNew-和-CMS" class="headerlink" title="ParNew 和 CMS"></a><strong>ParNew</strong> 和 <strong>CMS</strong></h3><ul><li>适用于内存在 <strong>20 G 以下</strong> 的情况</li><li>ParaNew：<ul><li><strong>ParNew</strong> 就是为了配合 <strong>CMS</strong> 使用，基于 <strong>Parallel Scavenge</strong> 的增强版本</li><li>a stop-the-world, copying collector which uses multiple GC threads.</li><li>It differs from “Parallel Scavenge” in that it has enhancements that make it usable with CMS</li><li>For Example, “ParNew” does the synchronization needed so that it can run during the concurrent phases of CMS</li></ul></li><li><p>CMS </p><ul><li>Concurrent Mark Sweep 的缩写</li><li>在JDK1.4版本后期引入，是里程碑式的GC，开启了 <strong>并发回收</strong> 的先河，但是由于 <strong>CMS</strong> 问题较多，目前没有任何一个版本的JDK使用 <strong>CMS</strong> 作为默认垃圾回收器。</li><li>并发回收：<ul><li>随着物理内存越来越大，传统垃圾回收器GC产生的STW时间已经长到无法忍受。因此，为了缩短STW时间，产生了并发垃圾回收器。</li><li>并发垃圾回收器工作（即GC）的大部分时间内，其他线程也是正常运行的。只在某些必要阶段，会把其他线程暂停，因此，大大缩短了STW时间。</li></ul></li><li><p>工作阶段：</p><ol><li>初始标记（initial mark）：STW，标记根对象。</li><li>并发标记（concurrent mark）：标记非垃圾对象。使用 <strong>三色标记</strong> 算法。</li><li>重新标记（remark）：STW，修正并发标记阶段中，由于其他线程同时运行，而产生的错标和漏标。使用 <strong>Incremental Update</strong> 算法。</li><li>并发清理（concurrent sweep）：清理垃圾。使用 <strong>标记清除</strong> 算法。</li></ol></li><li><p><strong>CMS</strong> 的问题：</p><ol><li><p>碎片化（Memory Fragmentation）：CMS默认使用标记清除算法，会产生内存碎片。</p><p> 解决方法：</p><p> -XX:UseCMSCompactAtFullCollection</p><p> -XX:CMSFullGCBeforeCompaction=5</p><p> 即进行了若干次（可配置，上例中是5）Full GC后，进行一次压缩算法。</p></li><li><p>浮动垃圾（Floating Garbage）</p><p> CMS并发回收过程中，产生的垃圾，称为浮动垃圾，浮动垃圾需要等到下一次GC时才会回收。</p><p> 但是浮动垃圾会产生下面2种情况：</p><ul><li><p>Concurrent Mode Failure：CMS和业务线程并发运行，在执行CMS的过程中有业务对象需要在老年代直接分配，例如大对象，但是老年代没有足够的空间来分配。</p></li><li><p>Promotion Failed：YGC后， Survivor空间容纳不了剩余对象，将要放入老年代，老年代有碎片或者不能容纳这些对象。</p><p>这两种情况，会进入STW，并降级使用Serial Old垃圾器进行FullGC，从而造成长时间的卡顿。</p><p>解决方法：+XX:CMSInitiatingOccupancyFraction=60</p><p>即适当调低老年代触发FullGC的阈值，以保证老年代有足够大的空间。</p></li></ul></li></ol></li></ul></li></ul><p><img src="/2020/10/27/JVM-垃圾回收（1）/12.png" alt="CMS"></p><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><ul><li>Garbage First 的缩写</li><li>逻辑上分代，物理上不分代</li><li>适用于堆内存在 <strong>100 G 以下</strong> 的情况</li><li>并发标记阶段使用 <strong>三色标记</strong> 算法；重新标记阶段使用 <strong>SATB</strong> (snapshot at the beginning) 算法。</li></ul><h2 id="不使用分代模型的垃圾回收器"><a href="#不使用分代模型的垃圾回收器" class="headerlink" title="不使用分代模型的垃圾回收器"></a>不使用分代模型的垃圾回收器</h2><h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><ul><li>适用于堆内存在 <strong>16 T 以下</strong> 的情况</li><li>使用 <strong>颜色指针（Colored Pointers）</strong> + <strong>读屏障（Load Barrier）</strong></li></ul><h3 id="Shenandoah"><a href="#Shenandoah" class="headerlink" title="Shenandoah"></a>Shenandoah</h3><ul><li>使用 <strong>颜色指针（Colored Pointers）</strong> + <strong>写屏障（Load Barrier）</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 运行时数据区及常用指令</title>
      <link href="/2020/10/21/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
      <url>/2020/10/21/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>JVM 运行时数据区的组成</li><li>栈帧</li><li>举例说明基于栈帧的运行机制</li><li>总结JVM中的常用指令</li></ul><a id="more"></a><h1 id="JVM-运行时数据区（Runtime-Data-areas）"><a href="#JVM-运行时数据区（Runtime-Data-areas）" class="headerlink" title="JVM 运行时数据区（Runtime Data areas）"></a>JVM 运行时数据区（Runtime Data areas）</h1><h2 id="JVM-运行时数据区的组成"><a href="#JVM-运行时数据区的组成" class="headerlink" title="JVM 运行时数据区的组成"></a>JVM 运行时数据区的组成</h2><ul><li>PC：Program Counter，程序计数器，保存了下一条指令的位置，每个线程都有一个PC</li><li>Heap: 堆</li><li>JVM stacks: JVM的栈，每个线程都有一个栈，每个方法都有一个栈帧，栈帧存储在栈中</li><li>native method stacks：本地方法（如JNI）的栈，无法调优、管理，一般不用考虑</li><li>Direct Memory：jdk1.4以后，为提高效率，NIO使用直接内存访问内核空间的内存（零拷贝）</li><li>method area：<ul><li>方法区，存放了class数据、Run-time Constant Pool。</li><li><strong>Permanent Generation</strong> 和 <strong>Meta Space</strong> 分别是 <strong>JDK1.8之前</strong> 和 <strong>JDK1.8及之后</strong> 对 method area 的实现</li><li>Perm Generation：<ol><li>&lt; JDK1.7</li><li>字符串常量存储在Perm Generation中</li><li>启动时可以指定Perm Generation大小，运行过程中大小不会变，存满即报OOM，FGC不会清理Perm Generation</li></ol></li><li>Meta Space<ol><li>>= JDK1.8</li><li>字符串常量位于堆</li><li>若不指定Meta Space大小，则大小受限于物理内存，会触发FGC</li></ol></li></ul></li></ul><p><img src="/2020/10/21/JVM-运行时数据区/1.1.png" alt="Runtime Data areas"></p><h2 id="关于栈帧"><a href="#关于栈帧" class="headerlink" title="关于栈帧"></a>关于栈帧</h2><ul><li>目前实际的CPU大都是基于寄存器的指令集，而JVM是基于栈的指令集。</li><li>栈帧是JVM运行的一个重要机制。</li><li>每个方法都有一个栈帧，栈帧存储在栈中</li><li>一个栈帧内包含以下部分：<ul><li>该方法的本地变量 Local Variables</li><li>该方法的操作数栈 Operand Stacks</li><li>动态链接 Dynamic Linking</li><li>返回地址 Retrun Address</li></ul></li></ul><p>接下来通过例子来说明JVM是如何运行的。</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>Talk is cheap. Show me the code!</p><h2 id="一道无聊的面试题"><a href="#一道无聊的面试题" class="headerlink" title="一道无聊的面试题"></a>一道无聊的面试题</h2><p>首先来看一道比较无聊的面试题：求下面这段代码的输出结果…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">8</span>;</span><br><span class="line">        i = i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是：8….还是9呢？</p><p>我们看一下编译后的字节码就了然了。使用之前介绍的jclasslib工具，分析编译出的class文件，找到其中的main方法：</p><p><img src="/2020/10/21/JVM-运行时数据区/2.1.png" alt="编译后的字节码"></p><p>图中左半部分是main()方法编译后的字节码，右半部分是本地变量，可以看到其中0号变量是args，即main函数的输入参数，1号变量是i。</p><p>接下来，我们来一条条分析指令：</p><ol><li><code>bipush 8</code>：将数字8放入操作数栈（即本方法的栈帧的Operand Stacks）中，现在栈中有一个数字8。</li><li><code>istore_1</code>：从栈中取出一个int数，并赋值给1号本地变量。即将栈中的8弹出，并赋值给i。 此时，i=8，栈中为空。</li><li><code>iload_1</code>：将1号本地变量入栈。此时，栈中又有了一个数字8。</li><li><code>iinc 1 by 1</code>：将1号本地变量加1。在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.iinc" target="_blank" rel="noopener">JVMS文档</a>中可以看到这条指令是不影响操作数栈的，因此，此时，i变为9，栈中仍有一个数字8。</li><li><code>istore_1</code>: 从栈中取出一个int数，并赋值给1号本地变量。即将栈中的8弹出，并赋值给i。 此时，i=8，栈中为空。</li><li><code>getstatic #2</code>：解析常量池中2号常量的引用，即System.out</li><li><code>iload_1</code>：将1号本地变量入栈。此时，栈中又有了一个数字8。</li><li><code>invokevirtual #3</code>：弹出栈中的数字8，并将其作为参数调用常量池中3号常量的方法引用，即println。于是打印出8。</li><li><code>return</code>：返回。</li></ol><p>虽然说看了字节码后，对于结果是了然了，但是，其实还是有一点小疑问的：</p><ul><li>可以看到 <code>i = i</code> 这句话编译成字节码后就变成了两句: <code>iload_1</code> 和 <code>istore_1</code>，实际上就是先把i的值压栈，再弹出来赋回给i。</li><li>而 <code>i++</code> 这句编译成字节码是 <code>iinc 1 by 1</code>，也就是把i的值加了1再赋值给i。</li><li>上面两个都没问题，可以问题是为啥 <code>iinc 1 by 1</code>要插在 <code>iload_1</code> 和 <code>istore_1</code>之间呢？如果是放在后面，那结果就是9了。</li><li>其实，如果把 <code>i = i++;</code> 改成 <code>j = i++</code>没有什么争议了，<code>iinc 1 by 1</code> 只要放在 <code>iload_1</code> 之后就可以，至于要不要放在<code>istore_1</code>后面，对结果其实没什么影响。可能编译器也没想到有人会写这么无聊的代码吧。</li></ul><p>接下来，我们把 <code>i = i++</code> 改为 <code>i = ++i;</code>再看看结果。</p><p><img src="/2020/10/21/JVM-运行时数据区/2.2.png" alt="i++改为++i"></p><p>当然，结果是9。可以看到唯一的变化就是 <code>iinc i by 1</code> 和 <code>iload_1</code> 的顺序换了下。这从 <code>i++</code> 和 <code>++i</code> 的语义上也是能够理解的。</p><p>从这个例子，我们应该可以大致感受到JVM是如何运行的了，基本上各个指令都是对 <strong>栈帧 Frame</strong> 里的 <strong>操作数栈 Operand Stacks</strong> 和 <strong>本地变量 Local Variables</strong> 的操作。</p><p>上面的例子中只是运行了一个static函数，其中也没有任何方法调用，因此整个过程中，栈中只有一个栈帧，接下来我们再来看看方法调用的情况。</p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><h3 id="调用没有返回值的方法"><a href="#调用没有返回值的方法" class="headerlink" title="调用没有返回值的方法"></a>调用没有返回值的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3_MethodWithoutReturn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test3_MethodWithoutReturn t = <span class="keyword">new</span> Test3_MethodWithoutReturn();</span><br><span class="line">        t.m1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图左边是 <strong>main</strong> 方法编译后的字节码和本地变量表，右边是 <strong>m1</strong> 方法的字节码和本地变量表：<br><img src="/2020/10/21/JVM-运行时数据区/2.3.png" alt="Test3_MethodWithoutReturn字节码"></p><p>下面我们来过一遍执行流程：</p><ol><li><p>首先执行main函数，线程栈中有1个main方法的栈帧：</p><ol><li><p><code>new #2</code>：在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.new" target="_blank" rel="noopener">JVMS文档</a>中可以得知，new指令会从该类的常量池中找到2号常量所代表的类（本例中就是<code>Test3_MethodWithoutReturn</code> 类），会为该类的一个实例在堆中分配空间，对其成员变量赋默认值（<font color="red"> <strong>注意</strong>：是默认值，不是初始值！默认值是每个类型各自的默认值，如int的默认值就是0，而初始值是指在构造方法中或成员变量声明处的赋值。赋初始值的操作是在构造函数执行时，才进行的</font>）。并且生成的实例的引用会放入操作数栈中。此时main方法的栈中的操作数栈中有了一个<code>Test3_MethodWithoutReturn</code>实例的引用。</p><p><img src="/2020/10/21/JVM-运行时数据区/3.1.png" alt="new #2"></p></li><li><p><code>dup</code>：将栈顶的元素复制一份入栈。此时，栈内有了两份同一个<code>Test3_MethodWithoutReturn</code>实例的引用。</p><p><img src="/2020/10/21/JVM-运行时数据区/3.2.png" alt="dup"></p></li><li><p><code>invokespecial #3</code>：将栈顶元素弹出作为参数，调用<code>Test3_MethodWithoutReturn</code>的构造方法。实际上栈顶元素就是 <strong>this</strong>，<font color="red">对于非静态方法来说，其本地变量的表第一个元素都是this，调用方法的时候也至少需要传入一个参数this（即实例的引用）</font>。此时main方法的栈中的操作数栈只剩一个<code>Test3_MethodWithoutReturn</code>实例的引用。</p><p><img src="/2020/10/21/JVM-运行时数据区/3.3.png" alt="invokespecial #3"></p></li><li><p><code>astore_1</code>：将栈顶元素弹出，赋值给1号本地变量，即t。此时t终于指向了初始化完成的<code>Test3_MethodWithoutReturn</code>实例，并且操作数栈又变为了空。</p><p><img src="/2020/10/21/JVM-运行时数据区/3.4.png" alt="astore_1"></p></li><li><p><code>aload_1</code>：将本地变量1入栈，此时栈中有1个元素：t。</p><p><img src="/2020/10/21/JVM-运行时数据区/3.5.png" alt="aload_1"></p></li><li><p><code>invokevirtual #4</code>：将栈顶元素t弹出作为参数，调用<strong>m1</strong>方法。正如之前所说，我们可以看到m1方法的本地变量表中，第一个元素就是this。</p><p><img src="/2020/10/21/JVM-运行时数据区/3.6.png" alt="invokevirtual #4"></p></li></ol></li><li><p>接下来就开始执行m1方法的字节码，线程栈中新压入了m1方法的栈帧：</p><ol><li><p><code>sipush 500</code>：将500放入m1栈帧的操作数栈中。</p><p><img src="/2020/10/21/JVM-运行时数据区/3.7.png" alt="sipush 500"></p></li><li><p><code>istore_1</code>：将栈顶元素弹出，并赋值给1号参数。即将i赋值为500</p><p><img src="/2020/10/21/JVM-运行时数据区/3.8.png" alt="istore_1"></p></li><li><p><code>return</code>：m1方法返回</p><p><img src="/2020/10/21/JVM-运行时数据区/3.9.png" alt="return"></p></li></ol></li><li><p>m1的栈帧弹出，线程栈中又只有1个main方法的栈帧，回到之前调用m1方法处，继续向下执行：</p><ol start="7"><li><code>return</code>： main方法返回。</li></ol></li></ol><h3 id="调用有返回值的方法"><a href="#调用有返回值的方法" class="headerlink" title="调用有返回值的方法"></a>调用有返回值的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4_MethodWithReturn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test4_MethodWithReturn t = <span class="keyword">new</span> Test4_MethodWithReturn();</span><br><span class="line">        t.m1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">m1</span><span class="params">()</span>    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>Test3_MethodWithoutReturn</code> 相比，只是在m1方法的最后加了一句 <code>return i;</code>。</p><p>下图左边是 <strong>main</strong> 方法编译后的字节码和本地变量表，右边是 <strong>m1</strong> 方法的字节码和本地变量表：</p><p><img src="/2020/10/21/JVM-运行时数据区/4.1.png" alt="Test4_MethodWithReturn字节码"></p><p>和 <code>Test3_MethodWithoutReturn</code> 对比，我们不难发现：</p><ul><li>m1方法的最后，先将i入栈，然后执行了 <code>ireturn</code> 指令。在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.ireturn" target="_blank" rel="noopener">JVMS文档</a>中可知，和 <code>return</code> 相比，除了从当前方法返回，<code>ireturn</code>还会把本方法栈帧中的栈顶元素弹出，并压入到调用者栈帧的栈顶，也就是说，<code>ireturn</code>之后，i的值500，被放入到了main方法的栈帧的栈顶。</li><li>而main方法在调用完m1方法后，多了一个 <code>pop</code> 指令，也就是把m1方法返回时压入的500弹了出来。</li></ul><h3 id="调用有返回值的方法，并接收返回值"><a href="#调用有返回值的方法，并接收返回值" class="headerlink" title="调用有返回值的方法，并接收返回值"></a>调用有返回值的方法，并接收返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5_GetMethodReturn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test5_GetMethodReturn t = <span class="keyword">new</span> Test5_GetMethodReturn();</span><br><span class="line">        <span class="keyword">int</span> a = t.m1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>Test4_MethodWithReturn</code> 相比，在main方法中，声明了一个变量a来接收m1方法的返回值。</p><p>下图左边是 <strong>main</strong> 方法编译后的字节码和本地变量表，右边是 <strong>m1</strong> 方法的字节码和本地变量表：</p><p><img src="/2020/10/21/JVM-运行时数据区/5.1.png" alt="Test5_GetMethodReturn字节码"></p><p>和 <code>Test4_MethodWithReturn</code> 相比，不难发现：</p><ul><li>main方法的本地变量表中多了一个2号变量a</li><li>main方法在调用完m1方法后，调用的 <code>pop</code> 指令变为了 <code>istore_2</code> 指令，即把返回的500从栈顶弹出，并赋值给2号本地变量a。</li></ul><h2 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h2><p>最后，我们再来看看递归调用在JVM中是如何运行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6_Recursion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test6_Recursion t = <span class="keyword">new</span> Test6_Recursion();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = t.m(<span class="number">3</span>);</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">m</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n * m(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图左边是 <strong>main</strong> 方法编译后的字节码和本地变量表，右边是 <strong>m</strong> 方法的字节码和本地变量表：</p><p><img src="/2020/10/21/JVM-运行时数据区/6.1.png" alt="Test6_Recursion字节码"></p><p>main方法没啥好说的，我们来看下m方法。</p><ol><li><p>我们直接从main方法调用了t.m(3)处开始分析，对应的字节码是 <code>invokevirtual #4</code>，执行这条语句后，线程栈中压入m(3)的栈帧，PC指向m方法的字节码开始运行</p><ol><li><p>执行前两条指令 <code>iload_1</code> 和 <code>iconst_1</code>，依次将1号本地变量n的值3和常量1压入m(3)栈帧的操作数栈中。</p><p><img src="/2020/10/21/JVM-运行时数据区/7.1.png" alt="step 1"></p></li><li><p>执行 <code>if_icmpne 7</code> 指令，将栈中的1和3弹出，比较两数，若相等，向下执行，若不等，跳转到代码段7，即跳过 <code>iconst_1</code> 和 <code>ireturn</code>， 从<code>iload_1</code>处开始执行。</p></li><li><p>向下依次执行 <code>iload_1</code> <code>mload_0</code> <code>iload_1</code> <code>iconst_1</code>，依次向操作数栈中压入n的值3，this引用，n的值3和常量1</p><p><img src="/2020/10/21/JVM-运行时数据区/7.2.png" alt="step 2"></p></li><li><p>执行 <code>isub</code> 指令，将栈顶的两个元素3和1弹出相减，并将结果2压回栈中</p><p><img src="/2020/10/21/JVM-运行时数据区/7.3.png" alt="step 3"></p></li><li><p>执行 <code>invokevirtual #4</code>指令，将栈顶的2和this弹出作为参数调用m方法，即执行m(2)。此时m(3)栈帧的操作数栈中还剩余一个元素3。线程栈中压入m(2)的栈帧，PC指针又指向m方法字节码的开始位置。</p><p><img src="/2020/10/21/JVM-运行时数据区/7.4.png" alt="step 4"></p></li></ol></li><li><p>执行m(2)的过程和执行m(3)类似，不再赘述，会继续执行m(1)。此时m(2)的栈帧的操作数栈中还剩余一个元素2。线程栈中压入m(1)的栈帧，PC指针又指向m方法字节码的开始位置。</p><p> <img src="/2020/10/21/JVM-运行时数据区/7.5.png" alt="step 5"></p></li><li><p>执行m(1)的过程和m(2)、m(3)略有不同。</p><ol><li><p>执行前两条指令 <code>iload_1</code> 和 <code>iconst_1</code>，依次将1号本地变量n的值1和常量1压入m(3)栈帧的操作数栈中。</p><p><img src="/2020/10/21/JVM-运行时数据区/7.6.png" alt="step 6"></p></li><li><p>执行 <code>if_icmpne 7</code> 指令，将栈中的1和1弹出，比较两数，相等，继续向下执行<code>iconst_1</code>，<br>向m(1)栈帧的操作数栈中压入常量1。</p><p><img src="/2020/10/21/JVM-运行时数据区/7.7.png" alt="step 7"></p></li><li><p>执行 <code>ireturn</code> 指令，将本方法，即m(1)栈帧的操作数栈顶元素1弹出，并压入调用方，即m(2)栈帧的操作数栈中，接着返回m(2)的 <code>imul</code>指令处继续执行，m(1)的栈帧从线程栈中弹出。</p><p><img src="/2020/10/21/JVM-运行时数据区/7.8.png" alt="step 8"></p></li></ol></li><li><p>至此，m(1)方法执行完成，返回到m(2)继续执行。</p><ol><li><p>执行 <code>imul</code> 指令，m(2)栈帧的操作数栈顶的两个元素1和2被弹出，相乘后，将结果2压回栈顶。</p></li><li><p>执行 <code>ireturn</code> 指令，将m(2)栈帧的操作数栈顶的元素2弹出，并压入调用方，即m(3)栈帧的操作数栈顶，接着返回m(2)的 <code>imul</code>指令处继续执行，m(2)的栈帧从线程栈中弹出。</p><p><img src="/2020/10/21/JVM-运行时数据区/7.9.png" alt="step 9"></p></li></ol></li><li><p>m(2)方法也执行完成，返回到m(3)继续执行，和m(2)的执行类似，栈顶两个元素2和3相乘，得到结果6，返回main方法。</p><p> <img src="/2020/10/21/JVM-运行时数据区/7.10.png" alt="step 10"></p></li><li><p>最终在main方法中，结果6赋值给main方法的2号本地变量x。</p></li></ol><h1 id="JVM-常用指令"><a href="#JVM-常用指令" class="headerlink" title="JVM 常用指令"></a>JVM 常用指令</h1><p>在上面的举例分析中，常用的JVM指令我们基本都接触过了，下面简单汇总下，具体可以查阅<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html" target="_blank" rel="noopener">JVMS文档</a>。</p><ul><li>变量读写<ul><li><strong>load</strong>：将本地变量的值压入操作数栈中，根据数据类型的不同，具体有aload，aaload，baload，caload，dload，faload，fload，iaload，iload，laload，lload，saload等</li><li><strong>store</strong>：将操作数栈顶元素弹出，并赋值给本地变量，根据数据类型的不同，具体有astore，aastore，bastore，castore，dstore，fastore，fstore，iastore，istore，lastore，llstore，sastore等</li></ul></li><li>栈操作<ul><li><strong>dup</strong>：复制栈顶元素</li><li><strong>push</strong>：将一个元素压入栈中</li><li><strong>pop</strong>：从栈顶弹出一个元素</li><li><strong>iconst</strong>：将一个常量压入栈中</li></ul></li><li>运算<ul><li><strong>add</strong>：加</li><li><strong>sub</strong>：减</li><li><strong>mul</strong>：乘</li><li><strong>div</strong>：除</li><li><strong>rem</strong>：取余</li><li><strong>neg</strong>：取相反数</li><li><strong>or</strong>：或</li><li><strong>xor</strong>：异或</li><li><strong>and</strong>：与</li><li><strong>inc</strong>：自加操作，注意这条指令不影响操作数栈，直接对本地变量操作</li></ul></li><li>比较跳转<ul><li><strong>if_acmp&lt;cond></strong>：引用比较跳转</li><li><strong>if_icmp&lt;cond></strong>：int值比较跳转</li><li><strong>if&lt;cond></strong>：int值和0比较跳转</li></ul></li><li>方法返回<ul><li><strong>return</strong> </li></ul></li><li>方法调用<ul><li><strong>invokestatic</strong>：调用static方法</li><li><strong>invokevirtual</strong>：调用某个对象的方法，自带多态</li><li><strong>invokeinterface</strong>：调用接口对象的方法</li><li><strong>invokespecial</strong>：调用可以直接定位、没有多态的方法（如private方法和构造方法）</li><li><strong>invokedynamic</strong>：lambda表达式、反射、其他动态语言（如scala kotlin）、CGLib或ASM动态产生的class，调用其中的方法</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Runtime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>class文件格式</title>
      <link href="/2020/10/21/class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
      <url>/2020/10/21/class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>class文件的格式</li><li>如何通过jclasslib插件解析class文件</li></ul><a id="more"></a><h1 id="class文件"><a href="#class文件" class="headerlink" title="class文件"></a>class文件</h1><ul><li>java文件通过javac编译后得到class文件</li><li>是二进制字节流</li></ul><p>比如一个最简单的java文件如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassFileFormatT01</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译完成后得到 <strong>ClassFileFormatT01.class</strong> 文件 ，可以通过 <strong>notepad++</strong> 中的 <strong>Hex-Editor</strong> 插件查看其16进制格式的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ca fe ba be 00 00 00 34 00 10 0a 00 03 00 0d 07 </span><br><span class="line">00 0e 07 00 0f 01 00 06 3c 69 6e 69 74 3e 01 00 </span><br><span class="line">03 28 29 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 </span><br><span class="line">6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 01 00 12 </span><br><span class="line">4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 </span><br><span class="line">6c 65 01 00 04 74 68 69 73 01 00 14 4c 43 6c 61 </span><br><span class="line">73 73 46 69 6c 65 46 6f 72 6d 61 74 54 30 31 3b </span><br><span class="line">01 00 0a 53 6f 75 72 63 65 46 69 6c 65 01 00 17 </span><br><span class="line">43 6c 61 73 73 46 69 6c 65 46 6f 72 6d 61 74 54 </span><br><span class="line">30 31 2e 6a 61 76 61 0c 00 04 00 05 01 00 12 43 </span><br><span class="line">6c 61 73 73 46 69 6c 65 46 6f 72 6d 61 74 54 30 </span><br><span class="line">31 01 00 10 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 </span><br><span class="line">6a 65 63 74 00 21 00 02 00 03 00 00 00 00 00 01 </span><br><span class="line">00 01 00 04 00 05 00 01 00 06 00 00 00 2f 00 01 </span><br><span class="line">00 01 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 </span><br><span class="line">07 00 00 00 06 00 01 00 00 00 01 00 08 00 00 00 </span><br><span class="line">0c 00 01 00 00 00 05 00 09 00 0a 00 00 00 01 00 </span><br><span class="line">0b 00 00 00 02 00 0c</span><br></pre></td></tr></table></figure><p>接下来我们就来看看这些看似毫无头绪的二进制码代表着什么。</p><h1 id="class文件格式"><a href="#class文件格式" class="headerlink" title="class文件格式"></a>class文件格式</h1><h2 id="class文件构成"><a href="#class文件构成" class="headerlink" title="class文件构成"></a>class文件构成</h2><p>一个class文件由以下部分组成，如下图所示：</p><p><img src="/2020/10/21/class文件格式/3.1.png" alt="class文件格式"></p><ul><li>class文件标志 <strong>Magic Number</strong>，4字节，固定为 0xcafe babe</li><li>版本号 <ul><li><strong>Minor Version</strong>：2字节，jdk1.8编译出的class文件固定为0x0000</li><li><strong>MajorVersion</strong>：2字节，jdk1.8编译出的class文件固定为0x0034</li></ul></li><li>常量池信息 <ul><li><strong>constant_pool_count</strong>：2字节，常量池内的常量的数量</li><li><strong>constant_pool</strong>：常量池，由于其保留了index为0的常量，因此常量池里实际的常量池数量为<strong>constant_pool_count - 1</strong></li></ul></li><li>访问修饰符 <strong>access flags</strong>：2字节，用于描述该类是public还是private等等</li><li>当前类 <strong>this_class</strong>：2字节，当前类在常量池中的index，如：本例中等于2，则找到常量池中的2#常量，即可找到<strong>ClassFileFormatT01</strong>类的信息</li><li>父类 <strong>super_class</strong>：2字节，父类在常量池中的index，如：本例中等于3，则找到常量池中的3#常量，即可找到父类<strong>java/lang/Object</strong>的信息</li><li>接口信息<ul><li><strong>interfaces_count</strong>：2字节</li><li><strong>interfaces</strong>：实际数量为 <strong>interfaces_count</strong></li></ul></li><li>属性信息 <ul><li><strong>fields_count</strong>：2字节</li><li><strong>fields</strong>：实际数量为 <strong>fields_count</strong></li></ul></li><li>方法信息 <ul><li><strong>methods_count</strong>：2字节</li><li><strong>methods</strong>：实际数量为 <strong>methods_count</strong></li></ul></li><li>附加属性信息 <ul><li><strong>attributes_count</strong>：2字节</li><li><strong>attributes</strong>：实际数量为 <strong>attributes_count</strong></li></ul></li></ul><h2 id="插件-jclasslib"><a href="#插件-jclasslib" class="headerlink" title="插件 jclasslib"></a>插件 jclasslib</h2><p>上一节只是对class文件的构成做了一个概览性质的描述，实际上还有很多细节，比如：常量池中某一个常量的格式是怎样的？</p><p>这些细节就放到文章最后以附录的形式贴上去吧，毕竟，一般也不太会人工一字节一字节的对着二进制码去解析。</p><p>我们可以通过 <strong>IDEA</strong> 中的 <strong>jclasslib</strong> 插件，方便的解析class文件。</p><p>安装完 <strong>jclasslib</strong> 插件后， 重启 <strong>IDEA</strong>，编译java文件，将光标放在该java文件中，就可以在 <strong>View</strong> 菜单下找到 <strong>Show Bytecode With jclasslib</strong>选项了。</p><p>我们通过 <strong>jclasslib</strong> 分析本文开头编译得到的 <strong>ClassFileFormatT01.class</strong> 文件，如下图所示：</p><p><img src="/2020/10/21/class文件格式/3.2.png" alt="jclasslib"></p><p>可以看到在弹出的页面的左侧框中，有 <strong>General Information</strong>、<strong>Constant Pool</strong>、<strong>Interfaces</strong>、<strong>Fields</strong>、<strong>Methods</strong>、<strong>Attributes</strong>几个大类，右侧框内则是选中条目的详细信息。</p><p>比如点击概览信息 General Information，我们能看到该类的jdk编译版本为1.8，常量池数量为16，访问级别为public，类名是ClassFileFormatT01，父类是 java/lang/Object，接口数量和属性数量为0，方法数量为1，附加属性数量为1。</p><p>点开ConstanPool，还能看到常量池中每个常量的具体信息。</p><p>比如在总览信息中，<strong>This class</strong> 是 <code>cp_info #2 &lt;ClassFileFormatT01&gt;</code>，就表示2号常量中保存了 <strong>This class</strong> 的信息，于是我们找到2号常量，如下图所示，可以看到2号常量是一个类型为 <strong>CONSTANT_Class_info</strong> 的常量，它有一个 <strong>Class name</strong> 属性，即类名，这个属性的值又指向了14号常量。</p><p><img src="/2020/10/21/class文件格式/3.3.png" alt="2号常量"></p><p>我们再去看14号常量，可以看到14号常量是一个类型为 <strong>CONSTANT_Utf8_Info</strong> 的常量，即字符串，字符串的内容就是 <strong>ClassFileFormatT01</strong>，即类名。</p><p><img src="/2020/10/21/class文件格式/3.4.png" alt="14号常量"></p><p>此外，还有个值得注意的地方：源码中，我们什么都没写，但是编译出来的class文件中却有1个方法，并且方法的名称是 <strong>init</strong>，也就是说java帮我们自动生成了一个构造方法。</p><p><img src="/2020/10/21/class文件格式/3.5.png" alt="构造方法"></p><p>我们再来简单看下这个构造方法的字节码，就3个指令（点击指令，可以直接链接到Oracle官网文档该指令的描述处，非常方便）：</p><ol><li>把0号本地变量压栈，0号变量可以在 <strong>init</strong> 下面的 <strong>Code</strong> 下面的 <strong>LocalVariableTable</strong>中找到，就是 <strong>this</strong></li><li>调用了一个方法，这个方法要去1号常量里找，实际上就是父类即 <strong>java/lang/Object</strong> 的构造方法。 </li><li>返回</li></ol><h1 id="附录：Class文件格式详情"><a href="#附录：Class文件格式详情" class="headerlink" title="附录：Class文件格式详情"></a>附录：Class文件格式详情</h1><p>。。。实在是太多了。。。</p><p>详见<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html" target="_blank" rel="noopener">《Java Virtual Machine Specification》的第四章 “<strong>4. The class File Format</strong>”</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> class文件 </tag>
            
            <tag> jclasslib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 基础知识</title>
      <link href="/2020/10/21/JVM-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/10/21/JVM-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JVM最基础的背景知识。</p><a id="more"></a><h1 id="Java从编码到执行"><a href="#Java从编码到执行" class="headerlink" title="Java从编码到执行"></a>Java从编码到执行</h1><ul><li>java文件通过javac编译成class文件</li><li>程序运行时，类加载器将class加载进内存</li><li>代码由<strong>字节码解释器</strong>解释运行 或 由<strong>JIT即时编译器</strong>编译成本地代码运行</li></ul><p><img src="/2020/10/21/JVM-基础知识/1.1.jpg" alt="Java从编码到执行"></p><h1 id="JVM-与-Java"><a href="#JVM-与-Java" class="headerlink" title="JVM 与 Java"></a>JVM 与 Java</h1><ul><li>Java： 一种跨平台的语言，即不需要修改代码即可在Windows、Linux、MacOS等多个平台上运行</li><li>JVM： <ul><li>一种跨语言的平台，任何语言，只要最后编译成符合规范的 <strong>.class</strong> 文件，即可在JVM上运行</li><li>是一种规范：<strong>Java Virtual Machine Specification</strong></li><li>是虚构出来的一台计算机：有字节码指令集、内存管理（如 栈、堆、方法区等）</li></ul></li></ul><h1 id="常见的-JVM-实现"><a href="#常见的-JVM-实现" class="headerlink" title="常见的 JVM 实现"></a>常见的 JVM 实现</h1><ul><li><p>HotSpot:</p><ul><li>由Oracle官方发布、维护</li><li><p>可通过 <code>java -version</code> 查看</p><p><img src="/2020/10/21/JVM-基础知识/1.2.jpg" alt="HotSpot"></p></li></ul></li><li>JRockit:<ul><li>BEA发布，曾号称世界上最快的JVM</li><li>被Oracle收购，已合并入HotSpot</li></ul></li><li>J9: IBM</li><li>Microsoft VM</li><li>Taobao VM: HotSpot 深度定制版本</li><li>Liquid VM: 直接针对硬件</li><li>azul zing: <ul><li>商业收费版本，非常贵</li><li>最新垃圾回收的业界标杆</li></ul></li></ul><h1 id="JDK、JRE、JVM的关系"><a href="#JDK、JRE、JVM的关系" class="headerlink" title="JDK、JRE、JVM的关系"></a>JDK、JRE、JVM的关系</h1><p><img src="/2020/10/21/JVM-基础知识/1.3.jpg" alt="JDK JRE JVM"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2018/10/02/algorithm-redBlackTree/"/>
      <url>/2018/10/02/algorithm-redBlackTree/</url>
      
        <content type="html"><![CDATA[<img src="/2018/10/02/algorithm-redBlackTree/1.1.jpg"><a id="more"></a><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p><p>红黑树的特性:<br>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p><h1 id="2-红黑树的应用"><a href="#2-红黑树的应用" class="headerlink" title="2.红黑树的应用"></a>2.红黑树的应用</h1><p>定理：一棵含有n个节点的红黑树的高度至多为2log(n+1).</p><p>证明：<br>    “一棵含有n个节点的红黑树的高度至多为2log(n+1)” 的逆否命题是 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。<br>    我们只需要证明逆否命题，即可证明原命题为真；即只需证明 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。</p><pre><code>从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x&apos;s black height)，记为bh(x)。关于bh(x)有两点需要说明：</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉排序树</title>
      <link href="/2018/10/01/algorithm-binarySortTree/"/>
      <url>/2018/10/01/algorithm-binarySortTree/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2018/09/27/algorithm-binaryTree/"/>
      <url>/2018/09/27/algorithm-binaryTree/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看，一棵二叉树！</p><img src="/2018/09/27/algorithm-binaryTree/1.1.jpg"><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>二叉树是每个节点最多有两个子树的树结构。</p><h2 id="形态"><a href="#形态" class="headerlink" title="形态"></a>形态</h2><p>如图2-1所示，二叉树有五种形态：</p><ol><li>节点数为0，空集</li><li>仅有一个根节点</li><li>仅有左树</li><li>仅有右树</li><li>左右树均有</li></ol><img src="/2018/09/27/algorithm-binaryTree/2.1.jpg" title="图2-1 二叉树的五种形态"><h2 id="满二叉树与完全二叉树"><a href="#满二叉树与完全二叉树" class="headerlink" title="满二叉树与完全二叉树"></a>满二叉树与完全二叉树</h2><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>如果二叉树中所有分支节点的度数都为2，并且叶子节点都在通一层次上，则二叉树为满二叉树。如图2-2所示：</p><img src="/2018/09/27/algorithm-binaryTree/2.2.jpg" title="图2-2 满二叉树"><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>对一棵具有n个节点的二叉树按层序排号，如果编号为i的节点与同样深度的满二叉树编号为i节点在二叉树中位置完全相同，就是完全二叉树。<br>满二叉树必须是完全二叉树，反之则不一定成立。如图2-3所示：</p><p><span id="tree_example"> </span><br><img src="/2018/09/27/algorithm-binaryTree/2.3.jpg" title="图2-3 完全二叉树"></p><p>完全二叉树有以下特点：</p><ol><li>叶子节点只能出现在最下一层</li><li>最下层叶子节点一定集中在左部连续位置。</li><li>倒数第二层，如有叶子节点，一定出现在右部连续位置。</li><li>同样节点树的二叉树，完全二叉树的深度最小。</li></ol><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ol><li>在二叉树的第i层上最多有 $ 2^{(i-1)} $ 个节点（i &gt;= 1）。</li><li>高度为k的二叉树，最多有 $ 2^k-1 $ 个节点 (k &gt;= 0)。</li><li>对任何一棵二叉树，如果其叶节点有n个，度为2的非叶子节点有m个，则n = m + 1。（该性质的证明见<a href="#appendix">附录</a>）</li><li>具有n个节点的完全二叉树的高度为 $ [log_2n] + 1 $</li></ol><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>由于二叉树每个节点最多只有两个子节点，因此通常每个节点中有两个指向子节点的指针，如图3-1所示：<br><img src="/2018/09/27/algorithm-binaryTree/3.1.jpg" title="图3-1 二叉树的存储结构"><br>有时为了回溯父节点方便，还会在节点中增加一个指向父节点的指针。</p><p>java代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Integer val;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    Node parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer val, Node left, Node right, Node parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getVal</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(Integer val)</span> </span>&#123; his.val = val; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeft</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> left; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(Node left)</span> </span>&#123; <span class="keyword">this</span>.left = left; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRight</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> right; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(Node right)</span> </span>&#123; <span class="keyword">this</span>.right = right; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getParent</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> parent; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(Node parent)</span> </span>&#123; <span class="keyword">this</span>.parent = parent; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>对于一棵二叉树而言，主要有遍历、查找、插入、删除、查询树的高度、树的节点数量以及某个节点的层次等操作。</p><p>我们知道二叉树中的每个节点又包含了两棵子二叉树，这本身就是一种递归思想的体现，因此对二叉树的大部分操作使用递归的思想都可以很方便的实现。</p><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p>广度优先遍历实际就是按层次遍历，按节点层次从低到高的顺序遍历所有节点。</p><p>比如<a href="#tree_example">图2-3</a>中的二叉树的广度优先遍历为：<br>1 2 3 4 5 6 7 8 9 10</p><p>广度优先遍历似乎不太好用递归实现。</p><p>广度优先遍历需要使用队列：<br>（1）首先向队列中插入二叉树的根节点<br>（2）检查队列中是否有元素，如果队列中没有元素，遍历结束，如果有元素，进行下一步<br>（3）将队列中的第一个节点弹出，遍历该节点<br>（4）检查弹出的节点是否有左右子节点，若有，将其插入队列中<br>（5）重复步骤（2）</p><p>该遍历方法运用了队列“先进先出”的特性，先插入的节点也先弹出被遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@brief</span> 广度优先遍历 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breadthFisrtTraverse</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    queue.add(node);</span><br><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node n = queue.removeFirst();</span><br><span class="line">        System.out.print(n.val + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n.left != <span class="keyword">null</span>)</span><br><span class="line">            queue.addLast(n.left);</span><br><span class="line">        <span class="keyword">if</span> (n.right != <span class="keyword">null</span>)</span><br><span class="line">            queue.addLast(n.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p>深度优先遍历是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</p><p>深度优先遍历根据遍历时根节点的位置又分为前序、中序和后续遍历。</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>前序遍历是指按照“根-&gt;左-&gt;右”的顺序，深度遍历二叉树。</p><p>比如<a href="#tree_example">图2-3</a>中的二叉树的前序遍历为：<br>1 2 4 8 9 5 10 3 6 7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@brief</span> 前序遍历 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)   <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印本节点内容</span></span><br><span class="line">    System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">    <span class="comment">// 打印左子树</span></span><br><span class="line">    preOrder(node.left);</span><br><span class="line">    <span class="comment">// 打印右子树</span></span><br><span class="line">    preOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历是指按照“左-&gt;根-&gt;右”的顺序，深度遍历二叉树。</p><p>比如<a href="#tree_example">图2-3</a>中的二叉树的中序遍历为：<br>8 4 9 2 10 5 1 6 3 7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@brief</span> 中序遍历 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)   <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印左子树</span></span><br><span class="line">    midOrder(node.left);</span><br><span class="line">    <span class="comment">// 打印本节点内容</span></span><br><span class="line">    System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">    <span class="comment">// 打印右子树</span></span><br><span class="line">    midOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>前序遍历是指按照“左-&gt;右-&gt;根”的顺序，深度遍历二叉树。</p><p>比如<a href="#tree_example">图2-3</a>中的二叉树的后序遍历为：<br>8 9 4 10 5 2 6 7 3 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@brief</span> 后序遍历 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)   <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印左子树</span></span><br><span class="line">    postOrder(node.left);</span><br><span class="line">    <span class="comment">// 打印右子树</span></span><br><span class="line">    postOrder(node.right);</span><br><span class="line">    <span class="comment">// 打印本节点内容</span></span><br><span class="line">    System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找、插入和删除"><a href="#查找、插入和删除" class="headerlink" title="查找、插入和删除"></a>查找、插入和删除</h2><p>节点的查找、插入和删除其实都和树的节点顺序有关，比如常用的二叉排序树(BST)中，左节点&lt;根&lt;右节点。因此相关内容将在二叉排序树中再细讲。</p><h2 id="查询树的高度"><a href="#查询树的高度" class="headerlink" title="查询树的高度"></a>查询树的高度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@brief</span> 查询以该节点为根的树的高度 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">height</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(height(node.left), height(node.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询树的节点数量"><a href="#查询树的节点数量" class="headerlink" title="查询树的节点数量"></a>查询树的节点数量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@brief</span> 查询以该节点为根的树的节点数量 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">nodesNum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + nodesNum(node.right) + nodesNum(node.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询节点的层次"><a href="#查询节点的层次" class="headerlink" title="查询节点的层次"></a>查询节点的层次</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@brief</span> 查询节点的层级 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">level</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == root) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> level(node.parent) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><span id="appendix">附录</span></h1><h2 id="性质3的证明"><a href="#性质3的证明" class="headerlink" title="性质3的证明"></a>性质3的证明</h2><p>试证明: 对任何一棵二叉树，如果其叶节点有n个，度为2的非叶子节点有m个，则n = m + 1。<br>证： 设一棵二叉树度为0的节点个数为 $ n_0 $, 度为1的节点个数为 $ n_1 $, 度为2的节点个数为 $ n_2 $, 二叉树的节点总数为 k 。<br>则：<br>$ k=0 \times n_0+1 \times n_1+2 \times n_2 + 1 $              —— (式 1)<br>$ k=n_0+n_1+n_2 $                                   —— (式 2)<br>两式相减可得：<br>$ n_0=n_2+1 $  —— (式 3)</p><p>由题可知：叶子节点即度为0的节点，即：$ n_0 = n $;<br>度为2的非叶子节点即度为2的节点，即：$ n_2 = m $;</p><p>代入式3可得：<br>$ n=m+1 $</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2018/09/10/algorithm-Tree/"/>
      <url>/2018/09/10/algorithm-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天说说树。下面这就是一棵树：<br><img src="/2018/09/10/algorithm-Tree/1.1.jpg"></p><p>当然我们今天要说的是一种数据结构 - 树。<br><a id="more"></a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>树是8种基础数据结构（数组Array、栈Stack、队列Queue、链表LinkedList、树Tree、图Graph、堆Heap、散列表HashTable）之一。</p><p>一棵树通常可以表示为图2-1的形式，由于其形似一棵倒置的树，它也因此而得名。<br><img src="/2018/09/10/algorithm-Tree/2.1.jpg" title="图2-1 树"></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>树(Tree)是包含n(n &gt;= 0)个节点的有穷集合。<br>当 n=0 时，称为 <strong>空树</strong>。<br>对于任一棵 <strong>非空树</strong>（n &gt; 0），其满足以下特性：</p><ul><li>树中的每个元素称之为 <strong>节点</strong>（node）</li><li>有一个特殊的节点称之为 <strong>根节点</strong>（root），根节点没有父节点</li><li>除根节点之外的其余数据元素被分为m（m&gt;=0）个互不相交的集合T1，T2，……，Tm-1，其中每一个集合Ti(1&lt;=i&lt;=m)本身也是一棵树，被称作原树的 <strong>子树</strong>（subtree）</li></ul><p>根据上述定义，可以判断图2-2中的均不是树<br><img src="/2018/09/10/algorithm-Tree/2.2.jpg" title="图2-2 非树"></p><p>我们也可以推导出树的一些性质:</p><ul><li>子树是不相交的</li><li>除了根节点没有父节点，其余每个节点有且只有一个父节点</li><li>一棵有n个节点的树，有n-1条边</li></ul><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>在笔者看来，树这种数据结构之所以存在有两方面原因：</p><ol><li>自然界中本来就存在着许多以树状结构存在的事物（比如公司或部门的组织架构，家族图谱等），而程序是对自然界事物的抽象，那么树这种数据结构的出现就非常自然了；</li><li>在一些大数据量的场景下，树这种数据结构的搜索、插入、删除的综合性能相较与数组、链表有优势。</li></ol><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul><li>节点的度（Degree）：一个节点含有的子树的个数称为该节点的度；</li><li>叶子节点（Leaf）：度为0的节点称为叶节点；</li><li>非终端节点或分支节点：度不为0的节点；</li><li>父节点（Parent）：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li><li>子节点（Child）：一个节点含有的子树的根节点称为该节点的子节点；</li><li>兄弟节点（Sibling）：具有相同父节点的节点互称为兄弟节点；</li><li>树的度：一棵树中，最大的节点的度称为树的度；</li><li>节点的层次（Level）：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li><li>树的高度或深度（Depth）：树中节点的最大层次；</li><li>祖先（Ancestor）：从根到该节点所经分支上的所有节点都称为该节点的祖先；</li><li>子孙（Descendant）：以某节点为根的子树中任一节点都称为该节点的子孙。</li></ul><h1 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h1><p>由于树的子节点的数量是不确定的，因此通常在节点内部使用链表在存储该节点的子节点，这种表示方法也被称为孩子兄弟表示法，即：</p><ul><li>每个节点都有一个指向其第一个孩子的指针；</li><li>每个节点都有一个指向其第一个右兄弟的指针。</li></ul><p>图2-1中的树的存储结构可以表示为图3-1所示：<br><img src="/2018/09/10/algorithm-Tree/3.1.jpg" title="图3-1 孩子兄弟表示法"></p><h1 id="分类及应用"><a href="#分类及应用" class="headerlink" title="分类及应用"></a>分类及应用</h1><h2 id="根据是否有序分类"><a href="#根据是否有序分类" class="headerlink" title="根据是否有序分类"></a>根据是否有序分类</h2><ul><li>无序树<br>树的任意节点的子节点没有顺序关系。</li><li>有序树<br>树的任意节点的子节点有顺序关系。</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是应用非常广泛的一种树。<br>二叉树是指：树的任意节点至多包含两棵子树。</p><ul><li>满二叉树<br>叶子节点都在同一层并且除叶子节点外的所有节点都有两个子节点。</li><li>完全二叉树<br>对于一颗二叉树，假设其深度为d（d&gt;1）。除第d层外的所有节点构成满二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树。</li><li>平衡二叉树<br>它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树。</li></ul><h2 id="常用的树"><a href="#常用的树" class="headerlink" title="常用的树"></a>常用的树</h2><ul><li>二叉查找树（又称二叉搜索树、二叉排序树、BST）<br>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；<br>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；<br>任意节点的左、右子树也分别为二叉查找树；<br>没有键值相等的节点。</li><li>红黑树<br>红黑树是一颗特殊的二叉查找树，它有自平衡的特性，主要用于解决二叉查找树在某些情况下退化为链表而导致性能下降的问题。</li><li>字典树<br>又称单词查找树，Trie树，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。</li><li>后缀树<br>后缀树（Suffix tree）就是包含一则字符串所有后缀的压缩Trie树。</li><li>霍夫曼树<br>带权路径最短的二叉树称为哈夫曼树或最优二叉树。</li><li>2-3树、B树、B+树、B*树<br>均为平衡查找树。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
