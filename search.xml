<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM 运行时数据区及常用指令]]></title>
    <url>%2F2020%2F10%2F21%2FJVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[前言 JVM 运行时数据区的组成 栈帧 举例说明基于栈帧的运行机制 总结JVM中的常用指令 JVM 运行时数据区（Runtime Data areas）JVM 运行时数据区的组成 PC：Program Counter，程序计数器，保存了下一条指令的位置，每个线程都有一个PC Heap: 堆 JVM stacks: JVM的栈，每个线程都有一个栈，每个方法都有一个栈帧，栈帧存储在栈中 native method stacks：本地方法（如JNI）的栈，无法调优、管理，一般不用考虑 Direct Memory：jdk1.4以后，为提高效率，NIO使用直接内存访问内核空间的内存（零拷贝） method area： 方法区，存放了class数据、Run-time Constant Pool。 Permanent Space 和 Meta Space 分别是 JDK1.8之前 和 JDK1.8及之后 对 method area 的实现 Perm Space： &lt; JDK1.7 字符串常量存储在Perm Space中 启动时可以指定Perm Space大小，运行过程中不会变，存满即报OOM，FGC不会清理Perm Space Meta Space >= JDK1.8 字符串常量位于堆 若不指定Meta Space大小，则大小受限于物理内存，会触发FGC 关于栈帧 目前实际的CPU大都是基于寄存器的指令集，而JVM是基于栈的指令集。 栈帧是JVM运行的一个重要机制。 每个方法都有一个栈帧，栈帧存储在栈中 一个栈帧内包含以下部分： 该方法的本地变量 Local Variables 该方法的操作数栈 Operand Stacks 动态链接 Dynamic Linking 返回地址 Retrun Address 接下来通过例子来说明JVM是如何运行的。 举例Talk is cheap. Show me the code! 一道无聊的面试题首先来看一道比较无聊的面试题：求下面这段代码的输出结果… 1234567public class Test1 &#123; public static void main(String[] args) &#123; int i = 8; i = i++; System.out.println(i); &#125;&#125; 答案是：8….还是9呢？ 我们看一下编译后的字节码就了然了。使用之前介绍的jclasslib工具，分析编译出的class文件，找到其中的main方法： 图中左半部分是main()方法编译后的字节码，右半部分是本地变量，可以看到其中0号变量是args，即main函数的输入参数，1号变量是i。 接下来，我们来一条条分析指令： bipush 8：将数字8放入操作数栈（即本方法的栈帧的Operand Stacks）中，现在栈中有一个数字8。 istore_1：从栈中取出一个int数，并赋值给1号本地变量。即将栈中的8弹出，并赋值给i。 此时，i=8，栈中为空。 iload_1：将1号本地变量入栈。此时，栈中又有了一个数字8。 iinc 1 by 1：将1号本地变量加1。在JVMS文档中可以看到这条指令是不影响操作数栈的，因此，此时，i变为9，栈中仍有一个数字8。 istore_1: 从栈中取出一个int数，并赋值给1号本地变量。即将栈中的8弹出，并赋值给i。 此时，i=8，栈中为空。 getstatic #2：解析常量池中2号常量的引用，即System.out iload_1：将1号本地变量入栈。此时，栈中又有了一个数字8。 invokevirtual #3：弹出栈中的数字8，并将其作为参数调用常量池中3号常量的方法引用，即println。于是打印出8。 return：返回。 虽然说看了字节码后，对于结果是了然了，但是，其实还是有一点小疑问的： 可以看到 i = i 这句话编译成字节码后就变成了两句: iload_1 和 istore_1，实际上就是先把i的值压栈，再弹出来赋回给i。 而 i++ 这句编译成字节码是 iinc 1 by 1，也就是把i的值加了1再赋值给i。 上面两个都没问题，可以问题是为啥 iinc 1 by 1要插在 iload_1 和 istore_1之间呢？如果是放在后面，那结果就是9了。 其实，如果把 i = i++; 改成 j = i++没有什么争议了，iinc 1 by 1 只要放在 iload_1 之后就可以，至于要不要放在istore_1后面，对结果其实没什么影响。可能编译器也没想到有人会写这么无聊的代码吧。 接下来，我们把 i = i++ 改为 i = ++i;再看看结果。 当然，结果是9。可以看到唯一的变化就是 iinc i by 1 和 iload_1 的顺序换了下。这从 i++ 和 ++i 的语义上也是能够理解的。 从这个例子，我们应该可以大致感受到JVM是如何运行的了，基本上各个指令都是对 栈帧 Frame 里的 操作数栈 Operand Stacks 和 本地变量 Local Variables 的操作。 上面的例子中只是运行了一个static函数，其中也没有任何方法调用，因此整个过程中，栈中只有一个栈帧，接下来我们再来看看方法调用的情况。 方法调用调用没有返回值的方法12345678910public class Test3_MethodWithoutReturn &#123; public static void main(String[] args) &#123; Test3_MethodWithoutReturn t = new Test3_MethodWithoutReturn(); t.m1(); &#125; public void m1() &#123; int i = 500; &#125;&#125; 下图左边是 main 方法编译后的字节码和本地变量表，右边是 m1 方法的字节码和本地变量表： 下面我们来过一遍执行流程： 首先执行main函数，线程栈中有1个main方法的栈帧： new #2：在JVMS文档中可以得知，new指令会从该类的常量池中找到2号常量所代表的类（本例中就是Test3_MethodWithoutReturn 类），会为该类的一个实例在堆中分配空间，对其成员变量赋默认值（ 注意：是默认值，不是初始值！默认值是每个类型各自的默认值，如int的默认值就是0，而初始值是指在构造方法中或成员变量声明处的赋值。赋初始值的操作是在构造函数执行时，才进行的）。并且生成的实例的引用会放入操作数栈中。此时main方法的栈中的操作数栈中有了一个Test3_MethodWithoutReturn实例的引用。 dup：将栈顶的元素复制一份入栈。此时，栈内有了两份同一个Test3_MethodWithoutReturn实例的引用。 invokespecial #3：将栈顶元素弹出作为参数，调用Test3_MethodWithoutReturn的构造方法。实际上栈顶元素就是 this，对于非静态方法来说，其本地变量的表第一个元素都是this，调用方法的时候也至少需要传入一个参数this（即实例的引用）。此时main方法的栈中的操作数栈只剩一个Test3_MethodWithoutReturn实例的引用。 astore_1：将栈顶元素弹出，赋值给1号本地变量，即t。此时t终于指向了初始化完成的Test3_MethodWithoutReturn实例，并且操作数栈又变为了空。 aload_1：将本地变量1入栈，此时栈中有1个元素：t。 invokevirtual #4：将栈顶元素t弹出作为参数，调用m1方法。正如之前所说，我们可以看到m1方法的本地变量表中，第一个元素就是this。 接下来就开始执行m1方法的字节码，线程栈中新压入了m1方法的栈帧： sipush 500：将500放入m1栈帧的操作数栈中。 istore_1：将栈顶元素弹出，并赋值给1号参数。即将i赋值为500 return：m1方法返回 m1的栈帧弹出，线程栈中又只有1个main方法的栈帧，回到之前调用m1方法处，继续向下执行： return： main方法返回。 调用有返回值的方法1234567891011public class Test4_MethodWithReturn &#123; public static void main(String[] args) &#123; Test4_MethodWithReturn t = new Test4_MethodWithReturn(); t.m1(); &#125; public int m1() &#123; int i = 500; return i; &#125;&#125; 和 Test3_MethodWithoutReturn 相比，只是在m1方法的最后加了一句 return i;。 下图左边是 main 方法编译后的字节码和本地变量表，右边是 m1 方法的字节码和本地变量表： 和 Test3_MethodWithoutReturn 对比，我们不难发现： m1方法的最后，先将i入栈，然后执行了 ireturn 指令。在JVMS文档中可知，和 return 相比，除了从当前方法返回，ireturn还会把本方法栈帧中的栈顶元素弹出，并压入到调用者栈帧的栈顶，也就是说，ireturn之后，i的值500，被放入到了main方法的栈帧的栈顶。 而main方法在调用完m1方法后，多了一个 pop 指令，也就是把m1方法返回时压入的500弹了出来。 调用有返回值的方法，并接收返回值1234567891011public class Test5_GetMethodReturn &#123; public static void main(String[] args) &#123; Test5_GetMethodReturn t = new Test5_GetMethodReturn(); int a = t.m1(); &#125; public int m1() &#123; int i = 500; return i; &#125;&#125; 和 Test4_MethodWithReturn 相比，在main方法中，声明了一个变量a来接收m1方法的返回值。 下图左边是 main 方法编译后的字节码和本地变量表，右边是 m1 方法的字节码和本地变量表： 和 Test4_MethodWithReturn 相比，不难发现： main方法的本地变量表中多了一个2号变量a main方法在调用完m1方法后，调用的 pop 指令变为了 istore_2 指令，即把返回的500从栈顶弹出，并赋值给2号本地变量a。 递归调用最后，我们再来看看递归调用在JVM中是如何运行的。 12345678910111213public class Test6_Recursion &#123; public static void main(String[] args) &#123; Test6_Recursion t = new Test6_Recursion(); int x = t.m(3); System.out.println(x); &#125; public int m(int n) &#123; if (n == 1) return 1; return n * m(n - 1); &#125;&#125; 下图左边是 main 方法编译后的字节码和本地变量表，右边是 m 方法的字节码和本地变量表： main方法没啥好说的，我们来看下m方法。 我们直接从main方法调用了t.m(3)处开始分析，对应的字节码是 invokevirtual #4，执行这条语句后，线程栈中压入m(3)的栈帧，PC指向m方法的字节码开始运行 执行前两条指令 iload_1 和 iconst_1，依次将1号本地变量n的值3和常量1压入m(3)栈帧的操作数栈中。 执行 if_icmpne 7 指令，将栈中的1和3弹出，比较两数，若相等，向下执行，若不等，跳转到代码段7，即跳过 iconst_1 和 ireturn， 从iload_1处开始执行。 向下依次执行 iload_1 mload_0 iload_1 iconst_1，依次向操作数栈中压入n的值3，this引用，n的值3和常量1 执行 isub 指令，将栈顶的两个元素3和1弹出相减，并将结果2压回栈中 执行 invokevirtual #4指令，将栈顶的2和this弹出作为参数调用m方法，即执行m(2)。此时m(3)栈帧的操作数栈中还剩余一个元素3。线程栈中压入m(2)的栈帧，PC指针又指向m方法字节码的开始位置。 执行m(2)的过程和执行m(3)类似，不再赘述，会继续执行m(1)。此时m(2)的栈帧的操作数栈中还剩余一个元素2。线程栈中压入m(1)的栈帧，PC指针又指向m方法字节码的开始位置。 执行m(1)的过程和m(2)、m(3)略有不同。 执行前两条指令 iload_1 和 iconst_1，依次将1号本地变量n的值1和常量1压入m(3)栈帧的操作数栈中。 执行 if_icmpne 7 指令，将栈中的1和1弹出，比较两数，相等，继续向下执行iconst_1，向m(1)栈帧的操作数栈中压入常量1。 执行 ireturn 指令，将本方法，即m(1)栈帧的操作数栈顶元素1弹出，并压入调用方，即m(2)栈帧的操作数栈中，接着返回m(2)的 imul指令处继续执行，m(1)的栈帧从线程栈中弹出。 至此，m(1)方法执行完成，返回到m(2)继续执行。 执行 imul 指令，m(2)栈帧的操作数栈顶的两个元素1和2被弹出，相乘后，将结果2压回栈顶。 执行 ireturn 指令，将m(2)栈帧的操作数栈顶的元素2弹出，并压入调用方，即m(3)栈帧的操作数栈顶，接着返回m(2)的 imul指令处继续执行，m(2)的栈帧从线程栈中弹出。 m(2)方法也执行完成，返回到m(3)继续执行，和m(2)的执行类似，栈顶两个元素2和3相乘，得到结果6，返回main方法。 最终在main方法中，结果6赋值给main方法的2号本地变量x。 JVM 常用指令在上面的举例分析中，常用的JVM指令我们基本都接触过了，下面简单汇总下，具体可以查阅JVMS文档。 变量读写 load：将本地变量的值压入操作数栈中，根据数据类型的不同，具体有aload，aaload，baload，caload，dload，faload，fload，iaload，iload，laload，lload，saload等 store：将操作数栈顶元素弹出，并赋值给本地变量，根据数据类型的不同，具体有astore，aastore，bastore，castore，dstore，fastore，fstore，iastore，istore，lastore，llstore，sastore等 栈操作 dup：复制栈顶元素 push：将一个元素压入栈中 pop：从栈顶弹出一个元素 iconst：将一个常量压入栈中 运算 add：加 sub：减 mul：乘 div：除 rem：取余 neg：取相反数 or：或 xor：异或 and：与 inc：自加操作，注意这条指令不影响操作数栈，直接对本地变量操作 比较跳转 if_acmp&lt;cond>：引用比较跳转 if_icmp&lt;cond>：int值比较跳转 if&lt;cond>：int值和0比较跳转 方法返回 return 方法调用 invokestatic：调用static方法 invokevirtual：调用某个对象的方法，自带多态 invokeinterface：调用接口对象的方法 invokespecial：调用可以直接定位、没有多态的方法（如private方法和构造方法） invokedynamic：lambda表达式、反射、其他动态语言（如scala kotlin）、CGLib或ASM动态产生的class，调用其中的方法]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class文件格式]]></title>
    <url>%2F2020%2F10%2F21%2Fclass%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 class文件的格式 如何通过jclasslib插件解析class文件 class文件 java文件通过javac编译后得到class文件 是二进制字节流 比如一个最简单的java文件如下：12public class ClassFileFormatT01 &#123;&#125; 编译完成后得到 ClassFileFormatT01.class 文件 ，可以通过 notepad++ 中的 Hex-Editor 插件查看其16进制格式的内容： 123456789101112131415161718ca fe ba be 00 00 00 34 00 10 0a 00 03 00 0d 07 00 0e 07 00 0f 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 00 04 74 68 69 73 01 00 14 4c 43 6c 61 73 73 46 69 6c 65 46 6f 72 6d 61 74 54 30 31 3b 01 00 0a 53 6f 75 72 63 65 46 69 6c 65 01 00 17 43 6c 61 73 73 46 69 6c 65 46 6f 72 6d 61 74 54 30 31 2e 6a 61 76 61 0c 00 04 00 05 01 00 12 43 6c 61 73 73 46 69 6c 65 46 6f 72 6d 61 74 54 30 31 01 00 10 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 00 21 00 02 00 03 00 00 00 00 00 01 00 01 00 04 00 05 00 01 00 06 00 00 00 2f 00 01 00 01 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 07 00 00 00 06 00 01 00 00 00 01 00 08 00 00 00 0c 00 01 00 00 00 05 00 09 00 0a 00 00 00 01 00 0b 00 00 00 02 00 0c 接下来我们就来看看这些看似毫无头绪的二进制码代表着什么。 class文件格式class文件构成一个class文件由以下部分组成，如下图所示： class文件标志 Magic Number，4字节，固定为 0xcafe babe 版本号 Minor Version：2字节，jdk1.8编译出的class文件固定为0x0000 MajorVersion：2字节，jdk1.8编译出的class文件固定为0x0034 常量池信息 constant_pool_count：2字节，常量池内的常量的数量 constant_pool：常量池，由于其保留了index为0的常量，因此常量池里实际的常量池数量为constant_pool_count - 1 访问修饰符 access flags：2字节，用于描述该类是public还是private等等 当前类 this_class：2字节，当前类在常量池中的index，如：本例中等于2，则找到常量池中的2#常量，即可找到ClassFileFormatT01类的信息 父类 super_class：2字节，父类在常量池中的index，如：本例中等于3，则找到常量池中的3#常量，即可找到父类java/lang/Object的信息 接口信息 interfaces_count：2字节 interfaces：实际数量为 interfaces_count 属性信息 fields_count：2字节 fields：实际数量为 fields_count 方法信息 methods_count：2字节 methods：实际数量为 methods_count 附加属性信息 attributes_count：2字节 attributes：实际数量为 attributes_count 插件 jclasslib上一节只是对class文件的构成做了一个概览性质的描述，实际上还有很多细节，比如：常量池中某一个常量的格式是怎样的？ 这些细节就放到文章最后以附录的形式贴上去吧，毕竟，一般也不太会人工一字节一字节的对着二进制码去解析。 我们可以通过 IDEA 中的 jclasslib 插件，方便的解析class文件。 安装完 jclasslib 插件后， 重启 IDEA，编译java文件，将光标放在该java文件中，就可以在 View 菜单下找到 Show Bytecode With jclasslib选项了。 我们通过 jclasslib 分析本文开头编译得到的 ClassFileFormatT01.class 文件，如下图所示： 可以看到在弹出的页面的左侧框中，有 General Information、Constant Pool、Interfaces、Fields、Methods、Attributes几个大类，右侧框内则是选中条目的详细信息。 比如点击概览信息 General Information，我们能看到该类的jdk编译版本为1.8，常量池数量为16，访问级别为public，类名是ClassFileFormatT01，父类是 java/lang/Object，接口数量和属性数量为0，方法数量为1，附加属性数量为1。 点开ConstanPool，还能看到常量池中每个常量的具体信息。 比如在总览信息中，This class 是 cp_info #2 &lt;ClassFileFormatT01&gt;，就表示2号常量中保存了 This class 的信息，于是我们找到2号常量，如下图所示，可以看到2号常量是一个类型为 CONSTANT_Class_info 的常量，它有一个 Class name 属性，即类名，这个属性的值又指向了14号常量。 我们再去看14号常量，可以看到14号常量是一个类型为 CONSTANT_Utf8_Info 的常量，即字符串，字符串的内容就是 ClassFileFormatT01，即类名。 此外，还有个值得注意的地方：源码中，我们什么都没写，但是编译出来的class文件中却有1个方法，并且方法的名称是 init，也就是说java帮我们自动生成了一个构造方法。 我们再来简单看下这个构造方法的字节码，就3个指令（点击指令，可以直接链接到Oracle官网文档该指令的描述处，非常方便）： 把0号本地变量压栈，0号变量可以在 init 下面的 Code 下面的 LocalVariableTable中找到，就是 this 调用了一个方法，这个方法要去1号常量里找，实际上就是父类即 java/lang/Object 的构造方法。 返回 附录：Class文件格式详情。。。实在是太多了。。。 详见《Java Virtual Machine Specification》的第四章 “4. The class File Format”]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>class文件</tag>
        <tag>jclasslib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM 基础知识]]></title>
    <url>%2F2020%2F10%2F21%2FJVM-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[前言JVM最基础的背景知识。 Java从编码到执行 java文件通过javac编译成class文件 程序运行时，类加载器将class加载进内存 代码由字节码解释器解释运行 或 由JIT即时编译器编译成本地代码运行 JVM 与 Java Java： 一种跨平台的语言，即不需要修改代码即可在Windows、Linux、MacOS等多个平台上运行 JVM： 一种跨语言的平台，任何语言，只要最后编译成符合规范的 .class 文件，即可在JVM上运行 是一种规范：Java Virtual Machine Specification 是虚构出来的一台计算机：有字节码指令集、内存管理（如 栈、堆、方法区等） 常见的 JVM 实现 HotSpot: 由Oracle官方发布、维护 可通过 java -version 查看 JRockit: BEA发布，曾号称世界上最快的JVM 被Oracle收购，已合并入HotSpot J9: IBM Microsoft VM Taobao VM: HotSpot 深度定制版本 Liquid VM: 直接针对硬件 azul zing: 商业收费版本，非常贵 最新垃圾回收的业界标杆 JDK、JRE、JVM的关系]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2018%2F10%2F02%2Falgorithm-redBlackTree%2F</url>
    <content type="text"><![CDATA[1.简介R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。 红黑树的特性:（1）每个节点或者是黑色，或者是红色。（2）根节点是黑色。（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]（4）如果一个节点是红色的，则它的子节点必须是黑色的。（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 2.红黑树的应用定理：一棵含有n个节点的红黑树的高度至多为2log(n+1). 证明： “一棵含有n个节点的红黑树的高度至多为2log(n+1)” 的逆否命题是 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。 我们只需要证明逆否命题，即可证明原命题为真；即只需证明 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。 从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x&apos;s black height)，记为bh(x)。关于bh(x)有两点需要说明：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉排序树]]></title>
    <url>%2F2018%2F10%2F01%2Falgorithm-binarySortTree%2F</url>
    <content type="text"><![CDATA[介绍原理数据结构插入删除遍历代码实现]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2018%2F09%2F27%2Falgorithm-binaryTree%2F</url>
    <content type="text"><![CDATA[前言看，一棵二叉树！ 介绍定义二叉树是每个节点最多有两个子树的树结构。 形态如图2-1所示，二叉树有五种形态： 节点数为0，空集 仅有一个根节点 仅有左树 仅有右树 左右树均有 满二叉树与完全二叉树满二叉树如果二叉树中所有分支节点的度数都为2，并且叶子节点都在通一层次上，则二叉树为满二叉树。如图2-2所示： 完全二叉树对一棵具有n个节点的二叉树按层序排号，如果编号为i的节点与同样深度的满二叉树编号为i节点在二叉树中位置完全相同，就是完全二叉树。满二叉树必须是完全二叉树，反之则不一定成立。如图2-3所示： 完全二叉树有以下特点： 叶子节点只能出现在最下一层 最下层叶子节点一定集中在左部连续位置。 倒数第二层，如有叶子节点，一定出现在右部连续位置。 同样节点树的二叉树，完全二叉树的深度最小。 二叉树的性质 在二叉树的第i层上最多有 $ 2^{(i-1)} $ 个节点（i &gt;= 1）。 高度为k的二叉树，最多有 $ 2^k-1 $ 个节点 (k &gt;= 0)。 对任何一棵二叉树，如果其叶节点有n个，度为2的非叶子节点有m个，则n = m + 1。（该性质的证明见附录） 具有n个节点的完全二叉树的高度为 $ [log_2n] + 1 $ 存储结构由于二叉树每个节点最多只有两个子节点，因此通常每个节点中有两个指向子节点的指针，如图3-1所示：有时为了回溯父节点方便，还会在节点中增加一个指向父节点的指针。 java代码：12345678910111213141516171819202122232425262728293031class Node &#123; Integer val; Node left; Node right; Node parent; public Node() &#123; &#125; public Node(Integer val, Node left, Node right, Node parent) &#123; this.val = val; this.left = left; this.right = right; this.parent = parent; &#125; public Integer getVal() &#123; return val; &#125; public void setVal(Integer val) &#123; his.val = val; &#125; public Node getLeft() &#123; return left; &#125; public void setLeft(Node left) &#123; this.left = left; &#125; public Node getRight() &#123; return right; &#125; public void setRight(Node right) &#123; this.right = right; &#125; public Node getParent() &#123; return parent; &#125; public void setParent(Node parent) &#123; this.parent = parent; &#125;&#125; 操作对于一棵二叉树而言，主要有遍历、查找、插入、删除、查询树的高度、树的节点数量以及某个节点的层次等操作。 我们知道二叉树中的每个节点又包含了两棵子二叉树，这本身就是一种递归思想的体现，因此对二叉树的大部分操作使用递归的思想都可以很方便的实现。 广度优先遍历广度优先遍历实际就是按层次遍历，按节点层次从低到高的顺序遍历所有节点。 比如图2-3中的二叉树的广度优先遍历为：1 2 3 4 5 6 7 8 9 10 广度优先遍历似乎不太好用递归实现。 广度优先遍历需要使用队列：（1）首先向队列中插入二叉树的根节点（2）检查队列中是否有元素，如果队列中没有元素，遍历结束，如果有元素，进行下一步（3）将队列中的第一个节点弹出，遍历该节点（4）检查弹出的节点是否有左右子节点，若有，将其插入队列中（5）重复步骤（2） 该遍历方法运用了队列“先进先出”的特性，先插入的节点也先弹出被遍历。 123456789101112131415/** @brief 广度优先遍历 */public void breadthFisrtTraverse(Node node) &#123; LinkedList&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); queue.add(node); while (queue.size() &gt; 0) &#123; Node n = queue.removeFirst(); System.out.print(n.val + " "); if (n.left != null) queue.addLast(n.left); if (n.right != null) queue.addLast(n.right); &#125;&#125; 深度优先遍历深度优先遍历是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。 深度优先遍历根据遍历时根节点的位置又分为前序、中序和后续遍历。 前序遍历前序遍历是指按照“根-&gt;左-&gt;右”的顺序，深度遍历二叉树。 比如图2-3中的二叉树的前序遍历为：1 2 4 8 9 5 10 3 6 7 1234567891011/** @brief 前序遍历 */public void preOrder(Node node) &#123; if (node == null) return; // 打印本节点内容 System.out.print(node.val + " "); // 打印左子树 preOrder(node.left); // 打印右子树 preOrder(node.right);&#125; 中序遍历中序遍历是指按照“左-&gt;根-&gt;右”的顺序，深度遍历二叉树。 比如图2-3中的二叉树的中序遍历为：8 4 9 2 10 5 1 6 3 7 1234567891011/** @brief 中序遍历 */public void midOrder(Node node) &#123; if (node == null) return; // 打印左子树 midOrder(node.left); // 打印本节点内容 System.out.print(node.val + " "); // 打印右子树 midOrder(node.right);&#125; 后序遍历前序遍历是指按照“左-&gt;右-&gt;根”的顺序，深度遍历二叉树。 比如图2-3中的二叉树的后序遍历为：8 9 4 10 5 2 6 7 3 1 1234567891011/** @brief 后序遍历 */public void postOrder(Node node) &#123; if (node == null) return; // 打印左子树 postOrder(node.left); // 打印右子树 postOrder(node.right); // 打印本节点内容 System.out.print(node.val + " ");&#125; 查找、插入和删除节点的查找、插入和删除其实都和树的节点顺序有关，比如常用的二叉排序树(BST)中，左节点&lt;根&lt;右节点。因此相关内容将在二叉排序树中再细讲。 查询树的高度123456/** @brief 查询以该节点为根的树的高度 */public Integer height(Node node) &#123; if (node == null) return 0; return 1 + Math.max(height(node.left), height(node.right));&#125; 查询树的节点数量123456/** @brief 查询以该节点为根的树的节点数量 */public Integer nodesNum(Node node) &#123; if (node == null) return 0; return 1 + nodesNum(node.right) + nodesNum(node.left);&#125; 查询节点的层次123456/** @brief 查询节点的层级 */public Integer level(Node node) &#123; if (node == root) return 1; return level(node.parent) + 1;&#125; 附录性质3的证明试证明: 对任何一棵二叉树，如果其叶节点有n个，度为2的非叶子节点有m个，则n = m + 1。证： 设一棵二叉树度为0的节点个数为 $ n_0 $, 度为1的节点个数为 $ n_1 $, 度为2的节点个数为 $ n_2 $, 二叉树的节点总数为 k 。则：$ k=0 \times n_0+1 \times n_1+2 \times n_2 + 1 $ —— (式 1)$ k=n_0+n_1+n_2 $ —— (式 2)两式相减可得：$ n_0=n_2+1 $ —— (式 3) 由题可知：叶子节点即度为0的节点，即：$ n_0 = n $;度为2的非叶子节点即度为2的节点，即：$ n_2 = m $; 代入式3可得：$ n=m+1 $]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2018%2F09%2F10%2Falgorithm-Tree%2F</url>
    <content type="text"><![CDATA[前言今天说说树。下面这就是一棵树： 当然我们今天要说的是一种数据结构 - 树。 介绍树是8种基础数据结构（数组Array、栈Stack、队列Queue、链表LinkedList、树Tree、图Graph、堆Heap、散列表HashTable）之一。 一棵树通常可以表示为图2-1的形式，由于其形似一棵倒置的树，它也因此而得名。 定义树(Tree)是包含n(n &gt;= 0)个节点的有穷集合。当 n=0 时，称为 空树。对于任一棵 非空树（n &gt; 0），其满足以下特性： 树中的每个元素称之为 节点（node） 有一个特殊的节点称之为 根节点（root），根节点没有父节点 除根节点之外的其余数据元素被分为m（m&gt;=0）个互不相交的集合T1，T2，……，Tm-1，其中每一个集合Ti(1&lt;=i&lt;=m)本身也是一棵树，被称作原树的 子树（subtree） 根据上述定义，可以判断图2-2中的均不是树 我们也可以推导出树的一些性质: 子树是不相交的 除了根节点没有父节点，其余每个节点有且只有一个父节点 一棵有n个节点的树，有n-1条边 意义在笔者看来，树这种数据结构之所以存在有两方面原因： 自然界中本来就存在着许多以树状结构存在的事物（比如公司或部门的组织架构，家族图谱等），而程序是对自然界事物的抽象，那么树这种数据结构的出现就非常自然了； 在一些大数据量的场景下，树这种数据结构的搜索、插入、删除的综合性能相较与数组、链表有优势。 相关术语 节点的度（Degree）：一个节点含有的子树的个数称为该节点的度； 叶子节点（Leaf）：度为0的节点称为叶节点； 非终端节点或分支节点：度不为0的节点； 父节点（Parent）：若一个节点含有子节点，则这个节点称为其子节点的父节点； 子节点（Child）：一个节点含有的子树的根节点称为该节点的子节点； 兄弟节点（Sibling）：具有相同父节点的节点互称为兄弟节点； 树的度：一棵树中，最大的节点的度称为树的度； 节点的层次（Level）：从根开始定义起，根为第1层，根的子节点为第2层，以此类推； 树的高度或深度（Depth）：树中节点的最大层次； 祖先（Ancestor）：从根到该节点所经分支上的所有节点都称为该节点的祖先； 子孙（Descendant）：以某节点为根的子树中任一节点都称为该节点的子孙。 存储模型由于树的子节点的数量是不确定的，因此通常在节点内部使用链表在存储该节点的子节点，这种表示方法也被称为孩子兄弟表示法，即： 每个节点都有一个指向其第一个孩子的指针； 每个节点都有一个指向其第一个右兄弟的指针。 图2-1中的树的存储结构可以表示为图3-1所示： 分类及应用根据是否有序分类 无序树树的任意节点的子节点没有顺序关系。 有序树树的任意节点的子节点有顺序关系。 二叉树二叉树是应用非常广泛的一种树。二叉树是指：树的任意节点至多包含两棵子树。 满二叉树叶子节点都在同一层并且除叶子节点外的所有节点都有两个子节点。 完全二叉树对于一颗二叉树，假设其深度为d（d&gt;1）。除第d层外的所有节点构成满二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树。 平衡二叉树它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树。 常用的树 二叉查找树（又称二叉搜索树、二叉排序树、BST）若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；任意节点的左、右子树也分别为二叉查找树；没有键值相等的节点。 红黑树红黑树是一颗特殊的二叉查找树，它有自平衡的特性，主要用于解决二叉查找树在某些情况下退化为链表而导致性能下降的问题。 字典树又称单词查找树，Trie树，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。 后缀树后缀树（Suffix tree）就是包含一则字符串所有后缀的压缩Trie树。 霍夫曼树带权路径最短的二叉树称为哈夫曼树或最优二叉树。 2-3树、B树、B+树、B*树均为平衡查找树。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
