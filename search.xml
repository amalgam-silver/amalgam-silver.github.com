<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[class文件格式]]></title>
    <url>%2F2020%2F10%2F21%2Fclass%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 class文件的格式 如何通过jclasslib插件解析class文件 class文件 java文件通过javac编译后得到class文件 是二进制字节流 比如一个最简单的java文件如下：12public class ClassFileFormatT01 &#123;&#125; 编译完成后得到 ClassFileFormatT01.class 文件 ，可以通过 notepad++ 中的 Hex-Editor插件查看其16进制格式的内容： 123456789101112131415161718ca fe ba be 00 00 00 34 00 10 0a 00 03 00 0d 07 00 0e 07 00 0f 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 00 04 74 68 69 73 01 00 14 4c 43 6c 61 73 73 46 69 6c 65 46 6f 72 6d 61 74 54 30 31 3b 01 00 0a 53 6f 75 72 63 65 46 69 6c 65 01 00 17 43 6c 61 73 73 46 69 6c 65 46 6f 72 6d 61 74 54 30 31 2e 6a 61 76 61 0c 00 04 00 05 01 00 12 43 6c 61 73 73 46 69 6c 65 46 6f 72 6d 61 74 54 30 31 01 00 10 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 00 21 00 02 00 03 00 00 00 00 00 01 00 01 00 04 00 05 00 01 00 06 00 00 00 2f 00 01 00 01 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 07 00 00 00 06 00 01 00 00 00 01 00 08 00 00 00 0c 00 01 00 00 00 05 00 09 00 0a 00 00 00 01 00 0b 00 00 00 02 00 0c 接下来我们就来看看这些看似毫无头绪的二进制码代表着什么。 class文件格式class文件构成一个class文件由以下部分组成，如下图所示： class文件标志 Magic Number，4字节，固定为 0xcafe babe 版本号 Minor Version：2字节，jdk1.8编译出的class文件固定为0x0000 MajorVersion：2字节，jdk1.8编译出的class文件固定为0x0034 常量池信息 constant_pool_count：2字节，常量池内的常量的数量 constant_pool：常量池，由于其保留了index为0的常量，因此常量池里实际的常量池数量为constant_pool_count - 1 访问修饰符 access flags：2字节，用于描述该类是public还是private等等 当前类 this_class：2字节，当前类在常量池中的index，如：本例中等于2，则找到常量池中的2#常量，即可找到ClassFileFormatT01类的信息 父类 super_class：2字节，父类在常量池中的index，如：本例中等于3，则找到常量池中的3#常亮，即可找到父类java/lang/Object的信息 接口信息 interfaces_count：2字节 interfaces：实际数量为 interfaces_count 属性信息 fields_count：2字节 fields：实际数量为 fields_count 方法信息 methods_count：2字节 methods：实际数量为 methods_count 附加属性信息 attributes_count：2字节 attributes：实际数量为 attributes_count 插件 jclasslib上一节只是对class文件的构成做了一个概览性质的描述，实际上还有很多细节，比如：常量池中某一个常量的格式是怎样的？ 这些细节就放到文章最后以附录的形式贴上去吧，毕竟，一般也不太会人工一字节一字节的对着二进制码去解析。 我们可以通过 IDEA 中的 jclasslib 插件，方便的解析class文件。 安装完 jclasslib 插件后， 重启 IDEA，编译java文件，将光标放在该java文件中，就可以在 View 菜单下找到 Show Bytecode With jclasslib选项了。 我们通过 jclasslib 分析本文开头编译得到的 ClassFileFormatT01.class 文件，如下图所示： 可以看到在弹出的页面的左侧框中，有 General Information、Constant Pool、Interfaces、Fields、Methods、Attributes几个大类，右侧框内测试选中条目的详细信息。 比如点击概览信息 General Information，我们能看到该类的jdk编译版本为1.8，常量池数量为16，访问级别为public，类名是ClassFileFormatT01，父类是 java/lang/Object，接口数量和属性数量为0，方法数量为1，附加属性数量为1。 点开ConstanPool，还能看到常量池中每个常亮的具体信息。 比如在总览信息中，This class 是 cp_info #2 &lt;ClassFileFormatT01&gt;，就表示2号常量中保存了 This class 的信息，于是我们找到2号常量，如下图所示，可以看到2号常量是一个类型为 CONSTANT_Class_info 的常量，它有一个 Class name 属性，即类名，这个属性的值又指向了14号常量。 我们再去看14号常量，可以看到14号常量是一个类型为 CONSTANT_Utf8_Info 的常亮，即字符串，字符串的内容就是 ClassFileFormatT01，即类名。 此外，还有个值得注意的地方：源码中，我们什么都没写，但是编译出来的class文件中却有1个方法，并且方法的名称是 init，也就是说java帮我们自动生成了一个构造方法。 我们再来简单看下这个构造方法的字节码，就3个指令（点击指令，可以直接链接到Oracle官网文档该指令的描述处，非常方便）： 把0号本地变量压栈，0号变量可以在 init 下面的 Code 下面的 LocalVariableTable中找到，就是 this 调用了一个方法，这个方法要去1号常量里找，实际上就是父类即 java/lang/Object 的构造方法。 返回 附录：Class文件格式详情。。。实在是太多了。。。 详见《Java Virtual Machine Specification》的第四章 “4. The class File Format”]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM 基础知识]]></title>
    <url>%2F2020%2F10%2F21%2FJVM-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[前言JVM最基础的背景知识。 Java从编码到执行 java文件通过javac编译成class文件 程序运行时，类加载器将class加载进内存 代码由字节码解释器解释运行 或 由JIT即时编译器编译成本地代码运行 JVM 与 Java Java： 一种跨平台的语言，即不需要修改代码即可在Windows、Linux、MacOS等多个平台上运行 JVM： 一种跨语言的平台，任何语言，只要最后编译成符合规范的 .class 文件，即可在JVM上运行 是一种规范：Java Virtual Machine Specification 是虚构出来的一台计算机：有字节码指令集、内存管理（如 栈、堆、方法区等） 常见的 JVM 实现 HotSpot: 由Oracle官方发布、维护 可通过 java -version 查看 JRockit: BEA发布，曾号称世界上最快的JVM 被Oracle收购，已合并入HotSpot J9: IBM Microsoft VM Taobao VM: HotSpot 深度定制版本 Liquid VM: 直接针对硬件 azul zing: 商业收费版本，非常贵 最新垃圾回收的业界标杆 JDK、JRE、JVM的关系]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2018%2F10%2F02%2Falgorithm-redBlackTree%2F</url>
    <content type="text"><![CDATA[1.简介R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。 红黑树的特性:（1）每个节点或者是黑色，或者是红色。（2）根节点是黑色。（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]（4）如果一个节点是红色的，则它的子节点必须是黑色的。（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 2.红黑树的应用定理：一棵含有n个节点的红黑树的高度至多为2log(n+1). 证明： “一棵含有n个节点的红黑树的高度至多为2log(n+1)” 的逆否命题是 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。 我们只需要证明逆否命题，即可证明原命题为真；即只需证明 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。 从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x&apos;s black height)，记为bh(x)。关于bh(x)有两点需要说明：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉排序树]]></title>
    <url>%2F2018%2F10%2F01%2Falgorithm-binarySortTree%2F</url>
    <content type="text"><![CDATA[介绍原理数据结构插入删除遍历代码实现]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2018%2F09%2F27%2Falgorithm-binaryTree%2F</url>
    <content type="text"><![CDATA[前言看，一棵二叉树！ 介绍定义二叉树是每个节点最多有两个子树的树结构。 形态如图2-1所示，二叉树有五种形态： 节点数为0，空集 仅有一个根节点 仅有左树 仅有右树 左右树均有 满二叉树与完全二叉树满二叉树如果二叉树中所有分支节点的度数都为2，并且叶子节点都在通一层次上，则二叉树为满二叉树。如图2-2所示： 完全二叉树对一棵具有n个节点的二叉树按层序排号，如果编号为i的节点与同样深度的满二叉树编号为i节点在二叉树中位置完全相同，就是完全二叉树。满二叉树必须是完全二叉树，反之则不一定成立。如图2-3所示： 完全二叉树有以下特点： 叶子节点只能出现在最下一层 最下层叶子节点一定集中在左部连续位置。 倒数第二层，如有叶子节点，一定出现在右部连续位置。 同样节点树的二叉树，完全二叉树的深度最小。 二叉树的性质 在二叉树的第i层上最多有 $ 2^{(i-1)} $ 个节点（i &gt;= 1）。 高度为k的二叉树，最多有 $ 2^k-1 $ 个节点 (k &gt;= 0)。 对任何一棵二叉树，如果其叶节点有n个，度为2的非叶子节点有m个，则n = m + 1。（该性质的证明见附录） 具有n个节点的完全二叉树的高度为 $ [log_2n] + 1 $ 存储结构由于二叉树每个节点最多只有两个子节点，因此通常每个节点中有两个指向子节点的指针，如图3-1所示：有时为了回溯父节点方便，还会在节点中增加一个指向父节点的指针。 java代码：12345678910111213141516171819202122232425262728293031class Node &#123; Integer val; Node left; Node right; Node parent; public Node() &#123; &#125; public Node(Integer val, Node left, Node right, Node parent) &#123; this.val = val; this.left = left; this.right = right; this.parent = parent; &#125; public Integer getVal() &#123; return val; &#125; public void setVal(Integer val) &#123; his.val = val; &#125; public Node getLeft() &#123; return left; &#125; public void setLeft(Node left) &#123; this.left = left; &#125; public Node getRight() &#123; return right; &#125; public void setRight(Node right) &#123; this.right = right; &#125; public Node getParent() &#123; return parent; &#125; public void setParent(Node parent) &#123; this.parent = parent; &#125;&#125; 操作对于一棵二叉树而言，主要有遍历、查找、插入、删除、查询树的高度、树的节点数量以及某个节点的层次等操作。 我们知道二叉树中的每个节点又包含了两棵子二叉树，这本身就是一种递归思想的体现，因此对二叉树的大部分操作使用递归的思想都可以很方便的实现。 广度优先遍历广度优先遍历实际就是按层次遍历，按节点层次从低到高的顺序遍历所有节点。 比如图2-3中的二叉树的广度优先遍历为：1 2 3 4 5 6 7 8 9 10 广度优先遍历似乎不太好用递归实现。 广度优先遍历需要使用队列：（1）首先向队列中插入二叉树的根节点（2）检查队列中是否有元素，如果队列中没有元素，遍历结束，如果有元素，进行下一步（3）将队列中的第一个节点弹出，遍历该节点（4）检查弹出的节点是否有左右子节点，若有，将其插入队列中（5）重复步骤（2） 该遍历方法运用了队列“先进先出”的特性，先插入的节点也先弹出被遍历。 123456789101112131415/** @brief 广度优先遍历 */public void breadthFisrtTraverse(Node node) &#123; LinkedList&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); queue.add(node); while (queue.size() &gt; 0) &#123; Node n = queue.removeFirst(); System.out.print(n.val + " "); if (n.left != null) queue.addLast(n.left); if (n.right != null) queue.addLast(n.right); &#125;&#125; 深度优先遍历深度优先遍历是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。 深度优先遍历根据遍历时根节点的位置又分为前序、中序和后续遍历。 前序遍历前序遍历是指按照“根-&gt;左-&gt;右”的顺序，深度遍历二叉树。 比如图2-3中的二叉树的前序遍历为：1 2 4 8 9 5 10 3 6 7 1234567891011/** @brief 前序遍历 */public void preOrder(Node node) &#123; if (node == null) return; // 打印本节点内容 System.out.print(node.val + " "); // 打印左子树 preOrder(node.left); // 打印右子树 preOrder(node.right);&#125; 中序遍历中序遍历是指按照“左-&gt;根-&gt;右”的顺序，深度遍历二叉树。 比如图2-3中的二叉树的中序遍历为：8 4 9 2 10 5 1 6 3 7 1234567891011/** @brief 中序遍历 */public void midOrder(Node node) &#123; if (node == null) return; // 打印左子树 midOrder(node.left); // 打印本节点内容 System.out.print(node.val + " "); // 打印右子树 midOrder(node.right);&#125; 后序遍历前序遍历是指按照“左-&gt;右-&gt;根”的顺序，深度遍历二叉树。 比如图2-3中的二叉树的后序遍历为：8 9 4 10 5 2 6 7 3 1 1234567891011/** @brief 后序遍历 */public void postOrder(Node node) &#123; if (node == null) return; // 打印左子树 postOrder(node.left); // 打印右子树 postOrder(node.right); // 打印本节点内容 System.out.print(node.val + " ");&#125; 查找、插入和删除节点的查找、插入和删除其实都和树的节点顺序有关，比如常用的二叉排序树(BST)中，左节点&lt;根&lt;右节点。因此相关内容将在二叉排序树中再细讲。 查询树的高度123456/** @brief 查询以该节点为根的树的高度 */public Integer height(Node node) &#123; if (node == null) return 0; return 1 + Math.max(height(node.left), height(node.right));&#125; 查询树的节点数量123456/** @brief 查询以该节点为根的树的节点数量 */public Integer nodesNum(Node node) &#123; if (node == null) return 0; return 1 + nodesNum(node.right) + nodesNum(node.left);&#125; 查询节点的层次123456/** @brief 查询节点的层级 */public Integer level(Node node) &#123; if (node == root) return 1; return level(node.parent) + 1;&#125; 附录性质3的证明试证明: 对任何一棵二叉树，如果其叶节点有n个，度为2的非叶子节点有m个，则n = m + 1。证： 设一棵二叉树度为0的节点个数为 $ n_0 $, 度为1的节点个数为 $ n_1 $, 度为2的节点个数为 $ n_2 $, 二叉树的节点总数为 k 。则：$ k=0 \times n_0+1 \times n_1+2 \times n_2 + 1 $ —— (式 1)$ k=n_0+n_1+n_2 $ —— (式 2)两式相减可得：$ n_0=n_2+1 $ —— (式 3) 由题可知：叶子节点即度为0的节点，即：$ n_0 = n $;度为2的非叶子节点即度为2的节点，即：$ n_2 = m $; 代入式3可得：$ n=m+1 $]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2018%2F09%2F10%2Falgorithm-Tree%2F</url>
    <content type="text"><![CDATA[前言今天说说树。下面这就是一棵树： 当然我们今天要说的是一种数据结构 - 树。 介绍树是8种基础数据结构（数组Array、栈Stack、队列Queue、链表LinkedList、树Tree、图Graph、堆Heap、散列表HashTable）之一。 一棵树通常可以表示为图2-1的形式，由于其形似一棵倒置的树，它也因此而得名。 定义树(Tree)是包含n(n &gt;= 0)个节点的有穷集合。当 n=0 时，称为 空树。对于任一棵 非空树（n &gt; 0），其满足以下特性： 树中的每个元素称之为 节点（node） 有一个特殊的节点称之为 根节点（root），根节点没有父节点 除根节点之外的其余数据元素被分为m（m&gt;=0）个互不相交的集合T1，T2，……，Tm-1，其中每一个集合Ti(1&lt;=i&lt;=m)本身也是一棵树，被称作原树的 子树（subtree） 根据上述定义，可以判断图2-2中的均不是树 我们也可以推导出树的一些性质: 子树是不相交的 除了根节点没有父节点，其余每个节点有且只有一个父节点 一棵有n个节点的树，有n-1条边 意义在笔者看来，树这种数据结构之所以存在有两方面原因： 自然界中本来就存在着许多以树状结构存在的事物（比如公司或部门的组织架构，家族图谱等），而程序是对自然界事物的抽象，那么树这种数据结构的出现就非常自然了； 在一些大数据量的场景下，树这种数据结构的搜索、插入、删除的综合性能相较与数组、链表有优势。 相关术语 节点的度（Degree）：一个节点含有的子树的个数称为该节点的度； 叶子节点（Leaf）：度为0的节点称为叶节点； 非终端节点或分支节点：度不为0的节点； 父节点（Parent）：若一个节点含有子节点，则这个节点称为其子节点的父节点； 子节点（Child）：一个节点含有的子树的根节点称为该节点的子节点； 兄弟节点（Sibling）：具有相同父节点的节点互称为兄弟节点； 树的度：一棵树中，最大的节点的度称为树的度； 节点的层次（Level）：从根开始定义起，根为第1层，根的子节点为第2层，以此类推； 树的高度或深度（Depth）：树中节点的最大层次； 祖先（Ancestor）：从根到该节点所经分支上的所有节点都称为该节点的祖先； 子孙（Descendant）：以某节点为根的子树中任一节点都称为该节点的子孙。 存储模型由于树的子节点的数量是不确定的，因此通常在节点内部使用链表在存储该节点的子节点，这种表示方法也被称为孩子兄弟表示法，即： 每个节点都有一个指向其第一个孩子的指针； 每个节点都有一个指向其第一个右兄弟的指针。 图2-1中的树的存储结构可以表示为图3-1所示： 分类及应用根据是否有序分类 无序树树的任意节点的子节点没有顺序关系。 有序树树的任意节点的子节点有顺序关系。 二叉树二叉树是应用非常广泛的一种树。二叉树是指：树的任意节点至多包含两棵子树。 满二叉树叶子节点都在同一层并且除叶子节点外的所有节点都有两个子节点。 完全二叉树对于一颗二叉树，假设其深度为d（d&gt;1）。除第d层外的所有节点构成满二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树。 平衡二叉树它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树。 常用的树 二叉查找树（又称二叉搜索树、二叉排序树、BST）若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；任意节点的左、右子树也分别为二叉查找树；没有键值相等的节点。 红黑树红黑树是一颗特殊的二叉查找树，它有自平衡的特性，主要用于解决二叉查找树在某些情况下退化为链表而导致性能下降的问题。 字典树又称单词查找树，Trie树，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。 后缀树后缀树（Suffix tree）就是包含一则字符串所有后缀的压缩Trie树。 霍夫曼树带权路径最短的二叉树称为哈夫曼树或最优二叉树。 2-3树、B树、B+树、B*树均为平衡查找树。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
